
</html><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            background-color: white;
            min-height: 100vh;
            width: 100%;
        }
        
        h2 {
            align-self: flex-start;
            margin-left: 20px;  /* Add some left margin for spacing */
        }

        .container {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: flex-start;
            padding: 10px;
            width: 100%;
            max-width: 100vw;
            box-sizing: border-box;
            gap: 20px;
            overflow-x: auto; /* Allow horizontal scroll if needed */
        }
        .plate-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 10px;
            flex: 1;
            min-width: 0; /* Allow shrinking */
            max-width: 100%; /* Allow growing */
        }
        .plate-container {
            display: grid;
            gap: 1px;
            border: 1px solid #ccc;
            background-color: white;
            padding: 2px;
            width: 45vw;
            height: auto;
            min-height: 300px;
            aspect-ratio: 1.5/1;
            box-sizing: border-box;
            position: relative;  /* Added for tooltips */
        }
        .well {
            background-color: white;
            text-align: center;
            cursor: pointer;
            border: 1px solid #ddd;
            user-select: none;
            border-radius: 20%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0;
            font-weight: 500;
            box-sizing: border-box;
            transition: all 0.2s ease;
        }
        /* Specific well sizes for different plate types */
        .plate-96 .well {
            font-size: clamp(8px, 1.2vw, 14px);
            min-width: calc(45vw / 13);  /* 12 columns + some spacing */
            min-height: calc(45vw / 13 * 0.75);  /* maintain aspect ratio */
        }

        .plate-384 .well {
            font-size: clamp(6px, 0.8vw, 10px);
            min-width: calc(45vw / 25);  /* 24 columns + some spacing */
            min-height: calc(45vw / 25 * 0.75);
        }

        .plate-1536 .well {
            font-size: clamp(4px, 0.6vw, 8px);
            min-width: calc(45vw / 49);  /* 48 columns + some spacing */
            min-height: calc(45vw / 49 * 0.75);
        }
        .selected {
            background-color: blue;
            color: white;
        }
        /* Hover and selection states */
        .well:hover {
            border-color: #007bff;
            box-shadow: 0 0 2px rgba(0, 123, 255, 0.3);
        }

        .well.selected {
            background-color: #007bff;
            color: white;
            border-color: #0056b3;
        }

        .well.mapped,
        .plate-container .well.mapped {
            color: white;
            border-color: rgba(0, 0, 0, 0.2);
            transition: background-color 0.2s ease;
        }
        .mapped {
            color: white;
        }
        .well-tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 1000;
            pointer-events: none;
            white-space: pre-line;
            max-width: 300px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .well-tooltip.visible {
            opacity: 1;
        }

        .well-tooltip::after {
            content: '';
            position: absolute;
            bottom: -4px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 4px;
            border-style: solid;
            border-color: rgba(0, 0, 0, 0.9) transparent transparent transparent;
        }
        
        .button-bar {
            margin: 20px 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: left;
            gap: 10px;
        }
        button {
            padding: 10px 15px;
            margin: 0 5px;
            font-size: 14px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        select {
            padding: 10px;
            font-size: 14px;
            margin-left: 10px;
        }
        .calculation-panel {
            background-color: white;
            padding: 5px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 100vw;
            box-sizing: border-box;
        }
        .input-group {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            gap: 20px;
            margin-bottom: 15px;
            align-items: center;
            min-width: 300px;
        }
        .input-field {
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 300px;
        }
        .input-field input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 150px;
        }
        .input-field label {
            font-size: 14px;
            color: #666;
        }
        .result {
            margin-top: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .compound-id-panel {
            margin: 20px 0;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: nowrap; /* Prevent wrapping */
            justify-content: space-between;
        }

        .compound-id-panel input {
            padding: 5px;
            font-size: 14px;
            width: 200px;
        }

        .compound-id-panel button {
            padding: 5px;
            font-size: 14px;
            cursor: pointer;
        }
        
        .volume-display {
            margin-top: 15px;
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .transfer-volume-box, .diluent-volume-box {
            background-color: #f8f9fa;
            padding: 10px 15px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .transfer-volume-box input {
            margin-top: 5px;
            padding: 5px;
            width: 100px;
            border: 1px solid #ddd;
            border-radius: 4px;
            min-width: 300px;
        }

        .diluent-volume-box span {
            display: block;
            margin-top: 5px;
            font-weight: bold;
            min-width: 100px;
            text-align: center;
        }

        .transfer-volume-box label, .diluent-volume-box label {
            display: block;
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }

        .backfill-section {
            margin-top: 20px;
            padding-top: 15px;
            border-top: none;
        }

        .backfill-section h4 {
            margin-bottom: 15px;
            color: #333;
        }

        .backfill-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }

        .backfill-controls button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .backfill-input-group {
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 300px;
        }

        .backfill-input-group label {
            min-width: 120px;
        }

        .backfill-input-group select {
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .plate-manager {
            width: 100%;
            max-width: 100vw; /* Change from fixed 1500px to 100vw */
            margin: 20px auto;
            padding: 10px;
            box-sizing: border-box;
        }


        .plate-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .plate-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .plate-tabs {
            position: relative; 
            display: flex;
            gap: 5px;
            margin: 10px 0;
            flex-wrap: wrap;
            z-index: 10;
        }

        .plate-tab {
            position: relative; 
            padding: 5px 15px;
            background-color: #e9ecef;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
            z-index: 10;
        }

        .plate-tab.active {
            background-color: #007bff;
            color: white;
            position: relative;
            z-index: 10;
        }

        .plate-tab .remove-plate {
            color: #dc3545;
            font-weight: bold;
            padding: 0 5px;
            cursor: pointer;
        }

        .plate-tab.active .remove-plate {
            color: white;
        }

        .plates-container {
            position: relative;
        }

        .plate-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.1);
            display: none;
            pointer-events: none;
        }

        /* Ensure source and destination tables fit within their plate sections */
        .plate-section {
            display: flex;
            flex-direction: column;
            margin-bottom: 20px;
        }

        .plate-section .attributes-table-container {
            margin-top: 10px;
            width: 100%;
        }

        .plate-section .replication-controls {
            order: 1;  /* Position replication controls between plate and table */
        }

        .plate-section .attributes-table-container {
            order: 2;  /* Position table at the end */
        }

        .replication-controls {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            align-items: center;
        }

        .replication-input {
            width: 60px;
            padding: 5px;
        }
        .selection-box {
            position: absolute;
            background-color: rgba(0, 123, 255, 0.2);
            border: 1px solid #007bff;
            pointer-events: none;
        }
        #serial-dilution-modal {
            display: none;  /* Will be set to block when modal is shown */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #serial-dilution-modal .modal-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.2);
            z-index: 998;
        }

        #serial-dilution-modal .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            width: 600px;
            max-width: 90vw;
            z-index: 999;
        }

        #serial-dilution-modal input[type="text"],
        #serial-dilution-modal input[type="number"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-top: 4px;
        }

        #serial-dilution-modal .input-group {
            margin-bottom: 20px;
        }

        #serial-dilution-modal label {
            display: block;
            margin-bottom: 5px;
            color: #666;
        }

        #serial-dilution-modal .button-bar {
            margin-top: 20px;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        #serial-dilution-modal .button-bar button {
            min-width: 100px;
        }

        /* Style for active selection of backfiller wells */
        .active-selection {
            border: 2px solid #007bff !important;
            box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            width: 100%;
            max-width: 1500px;
            margin: 20px auto;
        }
        .control-layout {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            width: 100%;
            max-width: 100vw;
            margin: 20px auto;
            padding: 0 20px;
            box-sizing: border-box;
        }

        .left-column {
            flex: 0 0 auto; /* Don't grow, don't shrink, size to content */
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .left-column + .calculation-panel {
            flex: 1;
            min-width: 300px; /* Minimum width for usability */
        }

        .left-column .calculation-panel {
            width: auto;
            min-width: 350px; /* Increase from 250px */
        }

        .well.active-compound {
            box-shadow: 0 0 10px #ffd700, 0 0 20px #ffd700;
            border: 2px solid #ffd700;
            z-index: 10;
        }

        #dilution-split-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 9999;
        }

        #dilution-split-modal .modal-content {
            position: relative;
            background-color: white;
            margin: 15% auto;
            padding: 20px;
            width: 80%;
            max-width: 600px;
            border-radius: 5px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        #dilution-split-modal .dilution-preview {
            margin: 20px 0;
            max-height: 300px;
            overflow-y: auto;
        }

        #dilution-split-modal table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        #dilution-split-modal th,
        #dilution-split-modal td {
            padding: 8px;
            border: 1px solid #ddd;
            text-align: left;
        }

        #dilution-split-modal thead {
            background-color: #f5f5f5;
        }

        /* Adjust the compound ID input width */
        .compound-id-panel input {
            width: 200px; 
        }

        /* Add media queries for smaller screens */
        @media screen and (max-width: 1200px) {
            .plate-container {
                width: 60vw;
            }
            
            .control-layout {
                grid-template-columns: 1fr 2fr; /* Adjust ratio on smaller screens */
            }
            
            .input-group {
                gap: 10px;
            }
        }

        @media screen and (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .plate-container {
                width: 90vw;
            }
            
            .control-layout {
                grid-template-columns: 1fr; /* Stack on mobile */
            }
            
            .plate-96 .well {
                font-size: clamp(6px, 1vw, 12px);
            }
            
            .plate-384 .well {
                font-size: clamp(4px, 0.8vw, 8px);
            }
            
            .plate-1536 .well {
                font-size: clamp(3px, 0.6vw, 6px);
            }
        }

        .well-tooltip::after {
            display: none !important; /* Hide the arrow */
        }

        /* Final CSS for ribbon layout with improved tooltips */
        .ribbon {
            display: flex;
            flex-wrap: nowrap;
            background-color: #f0f0f0;
            padding: 8px 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 15px;
            border-bottom: 1px solid #ddd;
            position: sticky;
            top: 0;
            z-index: 100;
            width: 100%;
            overflow-x: auto;
        }

        .ribbon-section {
            margin: 0 3px;
            padding: 0 7px;
            border-right: 1px solid #ddd;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
        }

        .ribbon-section:last-child {
            border-right: none;
        }

        .ribbon-section-title {
            font-weight: bold;
            margin-bottom: 4px;
            font-size: 12px;
            text-align: center;
            color: #555;
        }

        .ribbon-section-content {
            display: flex;
            flex-wrap: nowrap;
            gap: 5px;
            align-items: flex-start;
        }

        /* Adjust Manual Mapping section to fit content */
        .ribbon-mapping {
            flex-shrink: 0;
            width: auto;
        }

        .ribbon-mapping .ribbon-section-content {
            flex-wrap: nowrap;
            justify-content: flex-start;
        }

        /* Thicker dashed border for backfill section */
        .backfill-section {
            border-left: 2px dashed #999 !important;
            padding-left: 15px;
        }

        /* Fix Import/Export button alignment */
        .ribbon-section:nth-child(2) .ribbon-section-content {
            align-items: flex-start;
        }

        /* All buttons should have consistent styling */
        .ribbon button {
            padding: 4px 8px;
            font-size: 12px;
            white-space: nowrap;
            text-align: center;
            position: relative; /* For tooltip positioning */
        }

        /* Enhanced tooltip styling for disabled buttons */
        .ribbon button[disabled] {
            cursor: not-allowed;
            background-color: #ccc;
        }

        /* Custom tooltip for disabled buttons */
        .ribbon button[disabled][title]:hover::after {
            content: attr(title);
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
        }

        /* Add arrow to tooltip */
        .ribbon button[disabled][title]:hover::before {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 5px;
            border-style: solid;
            border-color: transparent transparent rgba(0, 0, 0, 0.8) transparent;
            z-index: 1000;
        }

        /* Input and select styles */
        .ribbon input[type="text"],
        .ribbon input[type="number"] {
            padding: 4px;
            font-size: 12px;
        }

        .ribbon select {
            padding: 3px;
            font-size: 12px;
        }

        /* Ensure label styling is consistent */
        .ribbon label {
            white-space: nowrap;
            font-size: 11px;
            display: block;
            margin-bottom: 3px;
        }

        /* Responsive adjustments */
        @media screen and (max-width: 1200px) {
            .ribbon {
                flex-wrap: wrap;
            }
            
            .ribbon-section {
                margin: 3px;
                border-right: none;
                border-bottom: 1px solid #ddd;
                padding-bottom: 5px;
                width: auto;
            }
            
            .ribbon-section:last-child {
                border-bottom: none;
            }
            
            .ribbon-mapping .ribbon-section-content {
                flex-wrap: wrap;
            }
        }

        /* Increase z-index for all modals and their backdrops */
        #serial-dilution-modal,
        #dilution-split-modal,
        #new-source-well-modal {
            z-index: 2000 !important; /* Higher than ribbon (100) and any other elements */
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
        }

        /* Ensure modal backdrop covers everything */
        #serial-dilution-modal .modal-backdrop,
        #dilution-split-modal .modal-backdrop {
            z-index: 2001 !important;
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background-color: rgba(0, 0, 0, 0.5) !important;
        }

        /* Position modal content above backdrop */
        #serial-dilution-modal .modal-content,
        #dilution-split-modal .modal-content,
        #new-source-well-modal > div {
            z-index: 2002 !important;
            position: fixed !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
            max-height: 80vh !important; /* Prevent modals from being too tall */
            overflow-y: auto !important; /* Add scrolling to modal content if needed */
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3) !important;
        }

        /* Add some padding to modal content */
        #serial-dilution-modal .modal-content,
        #dilution-split-modal .modal-content {
            padding: 25px !important;
        }

        /* Disable scrolling on body when modal is open */
        body.modal-open {
            overflow: hidden !important;
        }

        /* Ensure table headers don't overlap with modals */
        .attributes-table-container h3,
        .attributes-table-container th {
            z-index: 10 !important; /* Lower than modals */
        }

        /* Make sure the ribbon doesn't overlap modals */
        .ribbon {
            z-index: 100 !important;
        }

        .well.selected {
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.8) inset !important; /* Inner glow */
            border: 2px solid #007bff !important; /* Bold blue border */
            position: relative; /* Required for the pseudo-element */
            z-index: 5; /* Ensure selection styling is visible */
        }

        /* Add corner marker to make selection even more obvious */
        .well.selected::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 8px 8px 0 0;
            border-color: #007bff transparent transparent transparent;
            z-index: 6;
        }

        /* Styling for destination wells that received backfill */
        .well.backfilled {
            /* Base style for all backfilled wells */
            position: relative;
        }

        /* Add a subtle dashed border for backfilled destination wells */
        .well.backfilled::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 2px dashed rgba(128, 128, 128, 0.8);
            border-radius: inherit;
            pointer-events: none;
        }

        /* Specific styling for each backfill type */
        .well.backfilled.DMSO::after {
            border-color: rgba(128, 128, 128, 0.8); /* Gray for DMSO */
        }

        .well.backfilled.H2O::after {
            border-color: rgba(70, 130, 180, 0.8); /* Steel blue for water */
        }

        .well.backfilled.Buffer::after {
            border-color: rgba(60, 179, 113, 0.8); /* Medium sea green for buffer */
        }

        /* Clear, distinct selection styling that works with any background */
        .well.selected {
            /* Blue outline that works on any background */
            outline: 2px solid #0000ff !important;
            /* Additional inner white outline to make it visible against any color */
            box-shadow: inset 0 0 0 1px white !important;
            /* Make sure it's on top */
            z-index: 5 !important;
            position: relative !important;
        }

        /* Add a clear indicator for selected wells */
        .well.selected::before {
            content: "✓"; /* Checkmark */
            position: absolute;
            top: 0;
            right: 2px;
            color: white;
            background: blue;
            font-size: 8px;
            line-height: 10px;
            width: 10px;
            height: 10px;
            text-align: center;
            border-radius: 50%;
            z-index: 10;
        }

        /* Special styling for diluted source wells */
        .well.diluted-source {
            position: relative;
        }

        .well.diluted-source::after {
            content: "D";
            position: absolute;
            top: 1px;
            right: 1px;
            background-color: rgba(0, 100, 255, 0.7);
            color: white;
            font-size: 8px;
            line-height: 12px;
            width: 12px;
            height: 12px;
            text-align: center;
            border-radius: 50%;
            z-index: 10;
        }

        /* Enhanced styling for tooltip to show diluted source information */
        .well-tooltip.diluted-source-tooltip {
            border-left: 4px solid blue;
        }


    </style>
</head>
<body>
    <h2>CherryPick list Maker &#x1F352</h2>
    
    <!-- Ribbon Menu (Final Refined Layout) -->
    <div class="ribbon">
        <!-- 1. Compound ID Section -->
        <div class="ribbon-section">
            <div class="ribbon-section-title">Compound ID</div>
            <div class="ribbon-section-content" style="flex-direction: column; align-items: flex-start;">
                <input type="text" id="compound-id" placeholder="Enter Compound ID" style="width: 160px;">
                <button id="set-compound-id" style="margin-top: 5px; width: 160px;">Set Compound ID</button>
            </div>
        </div>
        
        <!-- 2. Import/Export Section (Left-aligned buttons) -->
        <div class="ribbon-section">
            <div class="ribbon-section-title">Import/Export</div>
            <div class="ribbon-section-content" style="flex-direction: column; gap: 5px; align-items: flex-start;">
                <div style="display: flex; align-items: center; width: 100%;">
                    <button id="import-csv-button" style="width: auto;">Import Source Well List</button>
                    <div style="display: flex; align-items: center; margin-left: 5px; font-size: 12px;">
                        <input type="checkbox" id="clear-before-import" checked>
                        <label for="clear-before-import" style="margin-left: 5px;">Clear before import</label>
                    </div>
                </div>
                <button id="export-source-info" style="width: auto;">Export Source Well List</button>
                <button id="export-destination-info" style="width: auto;">Export Dest. Well List</button>
            </div>
        </div>
        
        <!-- 3. Manual Mapping Section (Reorganized with Diluent under Final Volume) -->
        <div class="ribbon-section ribbon-mapping">
            <div class="ribbon-section-title">Manual Mapping</div>
            <div class="ribbon-section-content" style="flex-wrap: nowrap;">
                <!-- First column: Transfer Volume -->
                <div style="margin-right: 10px;">
                    <label for="transfer-volume" style="font-size: 11px;">Transfer Volume (nL)</label>
                    <input type="number" id="transfer-volume" step="0.01" min="0" style="width: 80px;">
                </div>
                
                <!-- Second column: Source and Destination Concentration aligned -->
                <div style="margin-right: 10px;">
                    <label for="source-concentration" style="font-size: 11px;">Source Conc.</label>
                    <div style="display: flex; gap: 2px;">
                        <input type="number" id="source-concentration" step="0.01" min="0" style="width: 60px;">
                        <select id="source-concentration-unit" style="width: 50px;">
                            <option value="mM">mM</option>
                            <option value="µM">µM</option>
                        </select>
                    </div>
                    
                    <label for="destination-concentration" style="font-size: 11px; margin-top: 8px;">Dest. Conc.</label>
                    <div style="display: flex; gap: 2px;">
                        <input type="number" id="destination-concentration" step="0.01" min="0" style="width: 60px;">
                        <select id="destination-concentration-unit" style="width: 50px;">
                            <option value="µM">µM</option>
                            <option value="nM">nM</option>
                        </select>
                    </div>
                </div>
                
                <!-- Third column: Final Volume, Diluent Volume and Map button -->
                <div style="margin-right: 15px;">
                    <label for="final-volume" style="font-size: 11px;">Final Vol. (µL)</label>
                    <input type="number" id="final-volume" step="0.1" min="0" style="width: 70px;">
                    
                    <div style="margin-top: 8px; font-size: 11px;">
                        Diluent Vol. (µL): <span id="diluent-volume" style="font-weight: 500;">0.00</span>
                    </div>
                    
                    <button id="map-button" disabled style="margin-top: 8px;">Map Wells</button>
                </div>
                
                <!-- Backfill subsection (with thicker border and tooltip) -->
                <div style="border-left: 2px dashed #999; padding-left: 15px; display: flex; flex-direction: column; justify-content: space-between;">
                    <div style="font-size: 11px; font-weight: bold; margin-bottom: 5px;">Backfill</div>
                    <div style="display: flex; align-items: center; gap: 5px; margin-bottom: 5px;">
                        <label for="backfill-liquid-selector" style="font-size: 11px;">Liquid:</label>
                        <select id="backfill-liquid-selector" style="width: 70px;">
                            <option value="DMSO">DMSO</option>
                            <option value="H2O">H2O</option>
                            <option value="Buffer">Buffer</option>
                        </select>
                    </div>
                    <div style="display: flex; align-items: center; gap: 5px; margin-bottom: 5px;">
                        <label for="backfill-volume" style="font-size: 11px;">Backfill to Vol. (nL):</label>
                        <input type="number" id="backfill-volume" value="100" min="2.5" step="2.5" style="width: 70px;">
                    </div>
                    <button id="apply-backfill" disabled title="Please select source and destination wells for backfill.">Apply Backfill</button>
                </div>
            </div>
        </div>
        
        <!-- 4. Serial Dilution Section -->
        <div class="ribbon-section">
            <div class="ribbon-section-title">Serial Dilution</div>
            <div class="ribbon-section-content">
                <button id="serial-dilution-button">Create Serial Dil.</button>
            </div>
        </div>
        
        <!-- 5. Save/Reset Section -->
        <div class="ribbon-section">
            <div class="ribbon-section-title">Save/Reset</div>
            <div class="ribbon-section-content" style="flex-direction: column; gap: 5px; align-items: stretch;">
                <div style="display: flex; gap: 5px; align-items: center;">
                    <button id="save-button" disabled style="flex-grow: 1;">Save Mappings</button>
                    <select id="format-selector" style="width: 60px;">
                        <option value="csv">CSV</option>
                        <option value="json">JSON</option>
                    </select>
                </div>
                <button id="reset-button">Reset Selections</button>
                <!-- Add this inside the Save/Reset section -->
                <button id="undo-button" disabled title="Undo last action">↩️ Undo</button>
            </div>
        </div>
    </div>

    <div class="plate-manager">
        <div class="container">
            <div class="plate-section">
                <h3>Source Plates</h3>
                <div class="plate-controls">
                    <div class="plate-selector">
                        <label>Source Plates:</label>
                        <button id="add-source-plate">Add Source Plate</button>
                        <input type="number" id="source-plate-number" placeholder="Plate #" min="1" value="1">
                    </div>
                </div>
                <div class="plate-tabs" id="source-plate-tabs"></div>
                <select id="source-plate-type-selector">
                    <option value="96">96 Well Plate</option>
                    <option value="384">384 Well Plate</option>
                    <option value="1536">1536 Well Plate</option>
                </select>
                <div class="plates-container">
                    <div class="plate-container" id="source-plate"></div>
                    <div class="plate-overlay" id="source-overlay"></div>
                </div>
                <div id="source-attributes-container"></div>
            </div>
            
            <div class="plate-section">
                <h3>Destination Plates</h3>
                <div class="plate-controls">
                    <div class="plate-selector">
                        <label>Destination Plates:</label>
                        <button id="add-destination-plate">Add Destination Plate</button>
                        <input type="number" id="destination-plate-number" placeholder="Plate #" min="1" value="1">
                    </div>
                </div>
                <div class="plate-tabs" id="destination-plate-tabs"></div>
                <select id="destination-plate-type-selector">
                    <option value="96">96 Well Plate</option>
                    <option value="384">384 Well Plate</option>
                    <option value="1536">1536 Well Plate</option>
                </select>
                <div class="plates-container">
                    <div class="plate-container" id="destination-plate"></div>
                    <div class="plate-overlay" id="destination-overlay"></div>
                </div>
                <div id="destination-attributes-container"></div>
                <div class="replication-controls">
                    <label>Replicate Mapping:</label>
                    <input type="number" id="replication-count" class="replication-input" min="1" value="1">
                    <button id="replicate-mapping">Replicate to New Plates</button>
                </div>
            </div>
        </div>        
    </div>  

    <!-- Serial Dilution Modal -->
    <div id="serial-dilution-modal">
        <div class="modal-backdrop"></div>
        <div class="modal-content">
            <h3>Serial Dilution Setup</h3>
            <div class="input-group">
                <div class="input-field">
                    <label>Source Well(s):</label>
                    <input type="text" id="serial-source-wells" readonly>
                </div>
                <div class="input-field">
                    <label>Source Concentration:</label>
                    <input type="number" id="serial-source-concentration" min="0" step="0.01">
                </div>
                <select id="serial-source-unit" style="height: 40px;">
                    <option value="mM">mM</option>
                    <option value="µM">µM</option>
                    <option value="nM">nM</option>
                </select>
            </div>
            
            <div class="input-group">
                <div class="input-field">
                    <label>Destination Wells:</label>
                    <input type="text" id="serial-destination-wells" readonly>
                </div>
                <div class="input-field">
                    <label>Top Dilution Concentration:</label>
                    <input type="number" id="serial-top-concentration" min="0" step="0.01">
                </div>
                <select id="serial-top-unit" style="height: 40px;">
                    <option value="µM">µM</option>
                    <option value="nM">nM</option>
                </select>
            </div>
            
            <div class="input-group">
                <div class="input-field">
                    <label>Final Volume (µL):</label>
                    <input type="number" id="serial-final-volume" min="0" step="0.01" value="100">
                </div>
                <div class="input-field">
                    <label>Dilution Factor:</label>
                    <input type="number" id="serial-dilution-fold" min="2" step="1" value="2">
                </div>
            </div>

            <div class="input-group">
                <div>
                    <label>Dilution Direction:</label>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                        <label><input type="radio" name="direction" value="top-bottom" checked> Top → Bottom</label>
                        <label><input type="radio" name="direction" value="bottom-top"> Bottom → Top</label>
                        <label><input type="radio" name="direction" value="left-right"> Left → Right</label>
                        <label><input type="radio" name="direction" value="right-left"> Right → Left</label>
                    </div>
                </div>
            </div>

            <div class="input-group">
                <div class="input-field">
                    <label>Number of Replicates:</label>
                    <input type="number" id="serial-replicates" min="1" value="1" step="1">
                </div>
            </div>
            
            <div class="input-group">
                <div class="input-field">
                    <label>Diluent Type:</label>
                    <select id="serial-diluent-type">
                        <option value="DMSO">DMSO</option>
                        <option value="H2O">H2O</option>
                        <option value="Buffer">Buffer</option>
                    </select>
                </div>
                <div class="input-field">
                    <label>Max Diluent %:</label>
                    <input type="number" id="serial-diluent-percent" min="0.1" max="100" step="0.1" value="2.0">
                </div>
                <div id="diluent-volume-indicator" style="display: flex; align-items: center; padding-top: 25px;">
                    <span>Max volume: <strong id="max-diluent-volume">2.00</strong> µL</span>
                </div>
            </div>

            <div class="button-bar">
                <button id="serial-dilution-cancel">Cancel</button>
                <button id="serial-dilution-ok">Apply Serial Dilution</button>
            </div>
        </div>
    </div>

    <!-- Dilution Split Modal -->
    <div id="dilution-split-modal">
        <div class="modal-backdrop"></div>
        <div class="modal-content">
            <h3>Dilution Split Required</h3>
            <div class="split-info">
                <p>Some dilutions require transfer volumes below 2.5nL. A diluted source well is needed.</p>
                
                <div class="dilution-preview">
                    <h4>Dilution Scheme Preview</h4>
                    <table id="dilution-split-table">
                        <thead>
                            <tr>
                                <th>Source #</th>
                                <th>Well Location</th>
                                <th>Concentration</th>
                                <th>Dilution Factor</th>
                                <th>Concentration Range</th>
                            </tr>
                        </thead>
                        <tbody id="dilution-split-preview">
                        </tbody>
                    </table>
                </div>

                <div id="new-source-wells-container">
                    <!-- New source wells will be added here dynamically -->
                </div>

                <div class="button-bar">
                    <button id="split-dilution-cancel">Cancel</button>
                    <button id="split-dilution-ok">Apply Split Dilution</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Well Tooltip -->
    <div id="well-tooltip" class="well-tooltip"></div>

    <!-- Hidden file input for CSV import -->
    <input type="file" id="csv-file-input" accept=".csv" style="display: none;">

    <!-- New Source Well Modal -->
    <div id="new-source-well-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center;">
        <div style="background-color: white; padding: 20px; border-radius: 10px; width: 400px;">
            <h3>New Source Well Dilution</h3>
            <p>Some transfers require volumes below 2.5 nL. A new diluted source well is needed.</p>
            
            <div style="margin: 10px 0;">
                <label>Original Source Concentration: 
                    <strong id="original-source-concentration"></strong>
                </label>
            </div>
            
            <div style="margin: 10px 0;">
                <label>Suggested Dilution Factor: 
                    <input type="number" id="new-source-well-dilution-factor" min="1" style="width: 100px;">
                </label>
            </div>
            
            <div style="margin: 10px 0;">
                <label>New Source Concentration: 
                    <strong id="new-source-concentration"></strong>
                </label>
            </div>
            
            <div style="margin: 10px 0;">
                <label>New Source Well: 
                    <input type="text" id="new-source-well" placeholder="Enter well (e.g., A1)" style="width: 100px;">
                </label>
            </div>
            
            <div style="display: flex; justify-content: space-between; margin-top: 20px;">
                <button id="cancel-new-source-well">Cancel</button>
                <button id="confirm-new-source-well">Confirm</button>
            </div>
        </div>
    </div>

    <script>
        // ----- DATA STRUCTURES & GLOBAL VARIABLES -----
        let selectedSourceWells = [];
        let selectedDestinationWells = [];
        let mappings = [];
        let isMouseDown = false;
        let selectionMode = null;
        let currentColorIndex = 0;
        let compoundID = null;
        let backfillingData = [];
        let selectedBackfillerWells = [];
        let isDragging = false;
        let startX = 0;
        let startY = 0;
        let selectionBox = null;
        let currentPlateId = null;
        let plates = {
            source: { 
                active: 1, 
                plates: { 
                    1: { 
                        name: "Plate 1", 
                        data: [] 
                    } 
                } 
            },
            destination: { 
                active: 1, 
                plates: { 
                    1: { 
                        name: "Plate 1", 
                        data: [] 
                    } 
                } 
            }
        };
        let dilutedSources = [];
        let globalDilutionSeries = [];
        let actionHistory = [];
        const MAX_HISTORY_LENGTH = 20; // Limit history length
        
        // Store compound-specific settings for serial dilution
        window.compoundSettings = {};
        
        // Source well data store for concentrations
        window.sourceWellDataStore = {};
        
        // Track which input field is active for serial dilution
        let activeSerialInput = null;
    
        // Colors for mapping visualization
        const colors = ['#FF5733', '#33FF57', '#3357FF', '#FF33A6', '#FFD433', '#A633FF'];

        const backfillerColors = {
            'DMSO': 'rgba(128, 128, 128, 0.7)',  // Gray for DMSO
            'H2O': 'rgba(70, 130, 180, 0.7)',    // Steel blue for water
            'Buffer': 'rgba(60, 179, 113, 0.7)'  // Medium sea green for buffer
        };
    
        // ----- UTILITY FUNCTIONS -----
        
        // Then add this function to save state before actions
        function saveStateForUndo(actionType, data) {
            // Create a snapshot of current state
            const snapshot = {
                actionType,
                data,
                mappings: JSON.parse(JSON.stringify(mappings)), // Deep copy
                sourceWellDataStore: JSON.parse(JSON.stringify(window.sourceWellDataStore)),
                selectedSourceWells: [...selectedSourceWells],
                selectedDestinationWells: [...selectedDestinationWells],
                compoundID: compoundID,
                plates: JSON.parse(JSON.stringify(plates))
            };
            
            // Add to history
            actionHistory.push(snapshot);
            
            // Limit history length
            if (actionHistory.length > MAX_HISTORY_LENGTH) {
                actionHistory.shift(); // Remove oldest entry
            }
            
            // Enable undo button
            document.getElementById('undo-button').disabled = actionHistory.length === 0;
        }

        // Add the undo function
        function undoLastAction() {
            if (actionHistory.length === 0) return;
            
            // Get the last state
            const lastState = actionHistory.pop();
            
            // Restore state
            mappings = lastState.mappings;
            window.sourceWellDataStore = lastState.sourceWellDataStore;
            
            // Clear current selections
            selectedSourceWells = [];
            selectedDestinationWells = [];
            document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
            
            // Restore compound ID
            compoundID = lastState.compoundID;
            document.getElementById('compound-id').value = compoundID || '';
            
            // Restore plates structure (if changed)
            plates = lastState.plates;
            
            // Refresh UI
            updatePlateTabs('source');
            updatePlateTabs('destination');
            
            // Refresh the active plates
            generatePlate('source-plate', parseInt(document.getElementById('source-plate-type-selector').value));
            generatePlate('destination-plate', parseInt(document.getElementById('destination-plate-type-selector').value));
            refreshPlateDisplay('source');
            refreshPlateDisplay('destination');
            updateWellAttributesTables();
            
            // Update buttons
            updateMapButton();
            updateSaveButton();
            updateApplyBackfillButton();
            document.getElementById('undo-button').disabled = actionHistory.length === 0;
            
            console.log(`Undid last action: ${lastState.actionType}`);
        }
        
        
        // Get row label from index (0 -> A, 1 -> B, etc.)
        function getRowLabel(index) {
            let label = "";
            while (index >= 0) {
                label = String.fromCharCode(65 + (index % 26)) + label;
                index = Math.floor(index / 26) - 1;
            }
            return label;
        }
    
        // Parse well position (A1 -> [0,0], B2 -> [1,1], etc.)
        function parseWellPosition(well) {
            const match = well.match(/([A-Z]+)(\d+)/);
            if (!match) return [0, 0];
            
            const row = match[1].split('').reduce((acc, char) => acc * 26 + char.charCodeAt(0) - 64, 0) - 1;
            const col = parseInt(match[2]) - 1;
            return [row, col];
        }
    
        // Sort wells by dilution direction and replicates
        function sortWellsByDirection(wells, direction, replicates) {
            const wellPositions = wells.map(well => {
                const [row, col] = parseWellPosition(well);
                return { well, row, col };
            });
    
            switch (direction) {
                case 'top-bottom':
                    return wellPositions
                        .sort((a, b) => {
                            const aGroup = Math.floor(a.row / replicates);
                            const bGroup = Math.floor(b.row / replicates);
                            return a.col - b.col || aGroup - bGroup || a.row - b.row;
                        })
                        .map(pos => pos.well);
                case 'bottom-top':
                    return wellPositions
                        .sort((a, b) => {
                            const aGroup = Math.floor(a.row / replicates);
                            const bGroup = Math.floor(b.row / replicates);
                            return a.col - b.col || bGroup - aGroup || b.row - a.row;
                        })
                        .map(pos => pos.well);
                case 'left-right':
                    return wellPositions
                        .sort((a, b) => {
                            const aGroup = Math.floor(a.col / replicates);
                            const bGroup = Math.floor(b.col / replicates);
                            return Math.floor(a.row) - Math.floor(b.row) || aGroup - bGroup || a.col - b.col;
                        })
                        .map(pos => pos.well);
                case 'right-left':
                    return wellPositions
                        .sort((a, b) => {
                            const aGroup = Math.floor(a.col / replicates);
                            const bGroup = Math.floor(b.col / replicates);
                            return Math.floor(a.row) - Math.floor(b.row) || bGroup - aGroup || b.col - a.col;
                        })
                        .map(pos => pos.well);
            }
        }
    
        // Get next color from rotation
        function getCompoundColor(compoundID) {
            if (!compoundID) return getNextColor();
            
            // First check if we already have a color for this compound in settings
            if (window.compoundSettings[compoundID] && window.compoundSettings[compoundID].color) {
                console.log(`Using stored color for ${compoundID}: ${window.compoundSettings[compoundID].color}`);
                return window.compoundSettings[compoundID].color;
            }
            
            // Next, check all existing mappings for this compound
            const existingMapping = mappings.find(m => 
                m.compoundID === compoundID || 
                m.compoundID === `${compoundID} (Diluted)` ||
                (m.originalCompoundID && m.originalCompoundID === compoundID)
            );
            
            if (existingMapping && existingMapping.color) {
                console.log(`Found existing mapping color for ${compoundID}: ${existingMapping.color}`);
                // Store for future use
                if (!window.compoundSettings[compoundID]) {
                    window.compoundSettings[compoundID] = {};
                }
                window.compoundSettings[compoundID].color = existingMapping.color;
                return existingMapping.color;
            }
            
            // If no existing color found, assign a new one
            const color = colors[currentColorIndex];
            currentColorIndex = (currentColorIndex + 1) % colors.length;
            console.log(`Assigning new color for ${compoundID}: ${color}`);
            
            // Store for future use
            if (!window.compoundSettings[compoundID]) {
                window.compoundSettings[compoundID] = {};
            }
            window.compoundSettings[compoundID].color = color;
            
            return color;
        }

        function getNextColor() {
            // Simple rotation through colors
            const color = colors[currentColorIndex];
            currentColorIndex = (currentColorIndex + 1) % colors.length;
            return color;
        }
    
        // Create a color with opacity
        function createColorWithOpacity(baseColor, opacity) {
            // Handle hex colors
            if (baseColor.startsWith('#')) {
                const r = parseInt(baseColor.slice(1, 3), 16);
                const g = parseInt(baseColor.slice(3, 5), 16);
                const b = parseInt(baseColor.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${opacity})`;
            }
            
            // Handle rgba colors
            if (baseColor.startsWith('rgba')) {
                return baseColor.replace(/rgba\(([^,]+),([^,]+),([^,]+),[^)]+\)/, 
                                    `rgba($1,$2,$3,${opacity})`);
            }
            
            // Handle rgb colors
            if (baseColor.startsWith('rgb')) {
                return baseColor.replace(/rgb\(([^,]+),([^,]+),([^)]+)\)/, 
                                    `rgba($1,$2,$3,${opacity})`);
            }
            
            // Default fallback
            return `rgba(128, 128, 128, ${opacity})`;
        }
    
        // Convert an array of wells to a range format
        function convertWellsToRange(wells) {
            if (!wells || wells.length === 0) return "";
    
            // Sort wells by row (letter) and column (number)
            wells.sort((a, b) => {
                const aRow = a.match(/[A-Z]+/)[0];
                const bRow = b.match(/[A-Z]+/)[0];
                const aCol = parseInt(a.match(/\d+/)[0]);
                const bCol = parseInt(b.match(/\d+/)[0]);
                
                if (aRow === bRow) {
                    return aCol - bCol;
                }
                return aRow.localeCompare(bRow);
            });
    
            const ranges = [];
            let currentRange = {
                row: null,
                start: null,
                end: null
            };
    
            for (const well of wells) { 
                const row = well.match(/[A-Z]+/)[0];
                const col = parseInt(well.match(/\d+/)[0]);
    
                if (!currentRange.row) {
                    // Start new range
                    currentRange = { row, start: col, end: col };
                } else if (row === currentRange.row && col === currentRange.end + 1) {
                    // Extend current range
                    currentRange.end = col;
                } else {
                    // End current range and start new one
                    if (currentRange.start === currentRange.end) {
                        ranges.push(`${currentRange.row}${currentRange.start}`);
                    } else {
                        ranges.push(`${currentRange.row}${currentRange.start}:${currentRange.row}${currentRange.end}`);
                    }
                    currentRange = { row, start: col, end: col };
                }
            }
    
            // Add the last range
            if (currentRange.row) {
                if (currentRange.start === currentRange.end) {
                    ranges.push(`${currentRange.row}${currentRange.start}`);
                } else {
                    ranges.push(`${currentRange.row}${currentRange.start}:${currentRange.row}${currentRange.end}`);
                }
            }
    
            return `{${ranges.join(';')}}`;
        }
    
        // Parse well range format like "{A1:A12}" or "{A1;A2;A3}" into array
        function parseWellRange(range) {
            if (!range) return [];
            
            // Handle ranges with colons (e.g., "A1:A12")
            const expandRange = (rangeStr) => {
                if (!rangeStr.includes(':')) return [normalizeWellID(rangeStr)];
                
                const [start, end] = rangeStr.split(':');
                const startRow = start.match(/[A-Z]+/)[0];
                const endRow = end.match(/[A-Z]+/)[0];
                const startCol = parseInt(start.match(/\d+/)[0]);
                const endCol = parseInt(end.match(/\d+/)[0]);
                
                if (startRow !== endRow) return [normalizeWellID(rangeStr)]; // Don't expand if rows are different
                
                const wells = [];
                for (let i = startCol; i <= endCol; i++) {
                    wells.push(normalizeWellID(`${startRow}${i}`));
                }
                return wells;
            };
    
            // Remove curly braces, split by semicolon, and expand any ranges
            return range.replace(/[{}]/g, '')
                .split(';')
                .map(part => part.trim())
                .filter(part => part)
                .flatMap(part => expandRange(part));
        }
    
        // Round volume to Echo increment (2.5nL)
        function roundToEchoIncrement(volumeNL) {
            const increment = 2.5;
            return Math.round(volumeNL / increment) * increment;
        }
    
        // Convert concentration to microMolar for calculations
        function convertToMicroMolar(value, unit) {
            switch(unit) {
                case 'mM': return value * 1000;
                case 'nM': return value / 1000;
                default: return value; // µM
            }
        }
    
        // Convert concentration from microMolar to specified unit
        function convertFromMicroMolar(value, unit) {
            switch(unit) {
                case 'mM': return value / 1000;
                case 'nM': return value * 1000;
                default: return value; // µM
            }
        }
    
        // Find available wells on the source plate
        function findAvailableSourceWells() {
            const sourcePlate = document.getElementById('source-plate');
            const availableWells = [];
            const currentSourcePlate = plates.source.active;
            
            // Find all wells that are already used in mappings
            const usedWells = new Set();
            
            // Add all wells used in mappings (both as source and diluted source)
            mappings.forEach(mapping => {
                // Skip if not for current source plate
                if (mapping.sourcePlate !== currentSourcePlate && 
                    mapping.destinationPlate !== currentSourcePlate) {
                    return;
                }
                
                // Add source wells
                if (mapping.source && mapping.sourcePlate === currentSourcePlate) {
                    const sourceWells = parseWellRange(mapping.source);
                    sourceWells.forEach(well => usedWells.add(well));
                }
                
                // Add diluted source wells
                if ((mapping.isDilutedSource || mapping.type === "DILUTED_SOURCE") && 
                    mapping.destinationPlate === currentSourcePlate) {
                    usedWells.add(mapping.destination);
                }
                
                // IMPORTANT FIX: Also add backfiller wells
                if (mapping.type === "BACKFILL_SOURCE" && 
                    mapping.destinationPlate === currentSourcePlate) {
                    usedWells.add(mapping.destination);
                }
            });
            
            // Check each well in the plate
            sourcePlate.querySelectorAll('.well').forEach(well => {
                const wellId = well.id.split('_')[1];  // Gets just the well position (e.g., "A1")
                
                // Add to available list if not used
                if (!usedWells.has(wellId)) {
                    availableWells.push(wellId);
                }
            });
    
            // Sort wells in a logical order
            return availableWells.sort((a, b) => {
                const aMatch = a.match(/([A-Z]+)(\d+)/);
                const bMatch = b.match(/([A-Z]+)(\d+)/);
                
                const aRow = aMatch[1];
                const bRow = bMatch[1];
                
                if (aRow === bRow) {
                    return parseInt(aMatch[2]) - parseInt(bMatch[2]);
                }
                
                return aRow.localeCompare(bRow);
            });
        }

        function updateMaxDiluentVolume() {
            const diluentPercent = parseFloat(document.getElementById('serial-diluent-percent').value);
            const finalVolume = parseFloat(document.getElementById('serial-final-volume').value);
            
            if (!isNaN(diluentPercent) && !isNaN(finalVolume)) {
                const maxDiluentVolume = (diluentPercent / 100) * finalVolume;
                document.getElementById('max-diluent-volume').textContent = maxDiluentVolume.toFixed(2);
            }
        }
    
        // ----- PLATE & WELL GENERATION -----
        
        // Generate a plate with wells and attach event listeners
        function generatePlate(plateId, plateType = 96) {
            const plate = document.getElementById(plateId);
            if (!plate) return;
            
            plate.innerHTML = '';
            plate.classList.remove('plate-96', 'plate-384', 'plate-1536');
            plate.classList.add(`plate-${plateType}`);
            
            let rows, cols;
            switch(parseInt(plateType)) {
                case 384:
                    rows = 16;
                    cols = 24;
                    break;
                case 1536:
                    rows = 32;
                    cols = 48;
                    break;
                default: // 96 well plate
                    rows = 8;
                    cols = 12;
            }
            
            plate.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            plate.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
            
            // Generate wells
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const well = document.createElement('div');
                    const wellId = `${getRowLabel(i)}${j + 1}`;
                    well.id = `${plateId}_${wellId}`;
                    well.className = 'well';
                    well.textContent = wellId;
                    
                    // Add event listeners
                    well.addEventListener('mousedown', (e) => {
                        e.preventDefault(); // Prevent text selection
                        isMouseDown = true;
                        currentPlateId = plateId;
                        selectionMode = plateId === 'source-plate' ? 'source' : 'destination';
                        toggleWellSelection(well, wellId, plateId);
                    });
                    
                    well.addEventListener('mouseover', () => {
                        if (isMouseDown && currentPlateId === plateId) {
                            toggleWellSelection(well, wellId, plateId);
                        }
                    });
                    
                    // Add tooltip event listeners
                    well.addEventListener('mousemove', (e) => {
                        const info = getWellInfo(well, plateId);
                        if (info) {
                            const tooltip = document.getElementById('well-tooltip');
                            tooltip.textContent = info;
                            tooltip.classList.add('visible');
                            
                            // Add special class for diluted source tooltips
                            if (well.classList.contains('diluted-source')) {
                                tooltip.classList.add('diluted-source-tooltip');
                            } else {
                                tooltip.classList.remove('diluted-source-tooltip');
                            }
                            
                            // Get viewport dimensions for boundary checking
                            const viewportWidth = window.innerWidth;
                            const viewportHeight = window.innerHeight;
                            
                            // Position tooltip near cursor but ensure it stays within viewport
                            const xOffset = 20; // Distance from cursor horizontally
                            const yOffset = 10; // Distance from cursor vertically
                            
                            // Set position directly with absolute values and !important to override any CSS
                            tooltip.style.cssText = `
                                position: fixed !important;
                                left: ${Math.min(e.clientX + xOffset, viewportWidth - tooltip.offsetWidth - 10)}px !important;
                                top: ${Math.min(e.clientY + yOffset, viewportHeight - tooltip.offsetHeight - 10)}px !important;
                                transform: none !important;
                                opacity: 1;
                            `;
                        }
                    });

                    well.addEventListener('mouseleave', () => {
                        const tooltip = document.getElementById('well-tooltip');
                        tooltip.classList.remove('visible');
                        tooltip.classList.remove('diluted-source-tooltip'); // Remove diluted source class
                        tooltip.style.opacity = '0';  // Force opacity to 0
                        tooltip.textContent = '';     // Clear tooltip content
                    });
                    
                    plate.appendChild(well);
                }
            }
        }
    
        // Create a plate tab
        function createPlateTab(type, number) {
            const tab = document.createElement('div');
            tab.className = 'plate-tab';
            tab.dataset.plateType = type;
            tab.dataset.number = number;
            
            if (number === plates[type].active) {
                tab.classList.add('active');
            }
            
            // Get custom name or default
            const plateName = plates[type].plates[number].name || `Plate ${number}`;
            
            tab.innerHTML = `
                <span class="plate-name" data-plate-type="${type}" data-plate-number="${number}">${plateName}</span>
                <span class="edit-plate-name" style="cursor:pointer; margin-left:3px;" title="Rename plate">✏️</span>
                <span class="remove-plate" data-number="${number}" style="margin-left:3px;">&times;</span>
            `;
            
            // Add click handler for the entire tab
            tab.addEventListener('click', (e) => {
                if (!e.target.classList.contains('remove-plate') && !e.target.classList.contains('edit-plate-name')) {
                    switchPlate(type, number);
                }
            });
            
            // Add click handler for remove button
            const removeBtn = tab.querySelector('.remove-plate');
            removeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                removePlate(type, number);
            });
            
            // Add click handler for edit button
            const editBtn = tab.querySelector('.edit-plate-name');
            editBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                promptRenamePlate(type, number);
            });
            
            return tab;
        }
    
        // Update plate tabs display
        function updatePlateTabs(type) {
            const tabsContainer = document.getElementById(`${type}-plate-tabs`);
            if (!tabsContainer) return;
            
            tabsContainer.innerHTML = '';
            
            // Get plate numbers and sort
            const plateNumbers = Object.keys(plates[type].plates)
                .map(Number)
                .sort((a, b) => a - b);
            
            // Create tabs for each plate
            plateNumbers.forEach(plateNumber => {
                const tab = createPlateTab(type, plateNumber);
                tabsContainer.appendChild(tab);
            });
        }
    
        // Switch to a different plate
        function switchPlate(type, number) {
            // Update active plate
            plates[type].active = parseInt(number);
            
            // Update tab visual states
            const tabsContainer = document.getElementById(`${type}-plate-tabs`);
            const allTabs = tabsContainer.querySelectorAll('.plate-tab');
            
            allTabs.forEach(tab => {
                if (parseInt(tab.dataset.number) === plates[type].active) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });
            
            // Clear visual indicators but preserve selection
            const plateContainer = document.getElementById(`${type}-plate`);
            plateContainer.querySelectorAll('.well').forEach(well => {
                const wasSelected = well.classList.contains('selected');
                well.classList.remove('mapped', 'backfilled', 'active-compound', 'highlighted-from-table');
                if (!wasSelected) {
                    well.classList.remove('selected'); // Only remove 'selected' if it wasn't selected
                }
                well.style.backgroundColor = '';
                if (!wasSelected) {
                    well.style.border = ''; // Don't reset border if selected
                }
            });
            
            // Refresh the plate display
            refreshPlateDisplay(type);
            
            // Clear previous table highlighting
            document.querySelectorAll('.table-row-selected').forEach(el => {
                el.classList.remove('table-row-selected');
            });
            
            // Update well attributes tables to reflect the current active plate
            updateWellAttributesTables();
            
            // Update compound list if applicable
            if (typeof updateCompoundList === 'function') {
                updateCompoundList();
            }
        }
    
        // Remove a plate
        function removePlate(type, number) {
            const numPlates = Object.keys(plates[type].plates).length;
            if (numPlates <= 1) {
                alert('Cannot remove the last plate');
                return;
            }
    
            // Remove plate data
            delete plates[type].plates[number];
            
            // If removing active plate, switch to another plate
            if (plates[type].active === parseInt(number)) {
                const remainingPlates = Object.keys(plates[type].plates)
                    .map(num => parseInt(num))
                    .sort((a, b) => a - b);
                plates[type].active = remainingPlates[0];
            }
            
            // Remove mappings associated with this plate
            mappings = mappings.filter(m => {
                if (type === 'source') {
                    return m.sourcePlate !== parseInt(number);
                } else {
                    return m.destinationPlate !== parseInt(number);
                }
            });
    
            // Update UI
            updatePlateTabs(type);
            refreshPlateDisplay(type);
            updateSaveButton();
        }
    
        // Add a new plate
        function addPlate(type) {
            const plateNumberInput = document.getElementById(`${type}-plate-number`);
            if (!plateNumberInput) return;
            
            const plateNumber = parseInt(plateNumberInput.value);
            
            if (isNaN(plateNumber) || plateNumber < 1) {
                alert('Please enter a valid plate number');
                return;
            }
            
            if (plates[type].plates[plateNumber]) {
                alert('Plate number already exists');
                return;
            }
            
            // Initialize new plate with default name
            plates[type].plates[plateNumber] = {
                name: `Plate ${plateNumber}`,
                data: []
            };
            
            // Switch to the new plate
            plates[type].active = plateNumber;
            
            // Update UI
            updatePlateTabs(type);
            refreshPlateDisplay(type);
        }
    
        // Refresh plate display
        function refreshPlateDisplay(type) {
            const plateContainer = document.getElementById(`${type}-plate`);
            
            // Clear existing styling
            plateContainer.querySelectorAll('.well').forEach(well => {
                well.classList.remove('selected', 'mapped', 'backfilled', 'diluted-source');
                well.style.backgroundColor = '';
                well.style.border = ''; // Reset any special borders
                // Clear data attributes
                well.removeAttribute('data-concentration');
            });
            
            // Get current plate number
            const currentPlateNumber = plates[type].active;
            
            if (type === 'source') {
                // Handle different mapping types for source plate
                
                // 1. First, handle backfiller wells
                const backfillerMappings = mappings.filter(m => 
                    m.type === "BACKFILL_SOURCE" &&
                    m.sourcePlate === currentPlateNumber &&
                    m.destinationPlate === currentPlateNumber
                );
                
                backfillerMappings.forEach(mapping => {
                    // Get well ID from destination field
                    const wellId = mapping.destination;
                    
                    // Find the element
                    const element = document.getElementById(`${type}-plate_${wellId}`);
                    if (element) {
                        element.classList.add('mapped');
                        element.style.backgroundColor = mapping.color;
                        // Add a distinctive border
                        element.style.border = '2px dashed #666';
                    }
                });
                
                // 2. Handle diluted source wells with enhanced styling
                const dilutedSourceMappings = mappings.filter(m => 
                    (m.type === "DILUTED_SOURCE" || m.isDilutedSource) &&
                    m.destinationPlate === currentPlateNumber
                );
                
                dilutedSourceMappings.forEach(mapping => {
                    const element = document.getElementById(`${type}-plate_${mapping.destination}`);
                    if (element) {
                        element.classList.add('mapped');
                        element.classList.add('diluted-source'); // Add special class
                        element.style.backgroundColor = mapping.color;
                        
                        // Store concentration and dilution factor as data attributes for tooltip
                        if (mapping.dilutedConcentration) {
                            element.dataset.concentration = `${mapping.dilutedConcentration} ${mapping.sourceUnit}`;
                            element.dataset.dilutionFactor = mapping.dilutionFactor;
                            element.dataset.isDilutedSource = 'true';
                        }
                    }
                });
                
                // 3. Handle original source wells
                const originalSourceMappings = mappings.filter(m => 
                    !m.type && // Not a typed mapping
                    !m.isDilutedSource && // Not a diluted source
                    m.sourcePlate === currentPlateNumber
                );
                
                originalSourceMappings.forEach(mapping => {
                    const sourceWells = parseWellRange(mapping.source);
                    sourceWells.forEach(wellId => {
                        const element = document.getElementById(`${type}-plate_${wellId}`);
                        if (element) {
                            element.classList.add('mapped');
                            element.style.backgroundColor = mapping.color;
                        }
                    });
                });
            } 
            else {
                // Handle destination plate mappings
                const destinationMappings = mappings.filter(m => 
                    (m.type === "DESTINATION" || (!m.type && !m.isDilutedSource)) && // Handle legacy
                    m.destinationPlate === currentPlateNumber
                );
                
                destinationMappings.forEach(mapping => {
                    const element = document.getElementById(`${type}-plate_${mapping.destination}`);
                    if (element) {
                        element.classList.add('mapped');
                        element.style.backgroundColor = mapping.color;
                    }
                });
                
                // Also handle backfill destination mappings
                const backfillMappings = mappings.filter(m =>
                    m.type === "BACKFILL" &&
                    m.destinationPlate === currentPlateNumber
                );

                backfillMappings.forEach(mapping => {
                    const element = document.getElementById(`${type}-plate_${mapping.destination}`);
                    if (element) {
                        // For backfill, add special styling
                        element.classList.add('backfilled');
                        
                        // Add class for specific backfill type to show correct border color
                        const backfillType = mapping.backfillType || 'DMSO'; // Default to DMSO
                        element.classList.add(backfillType);
                        
                        // Show backfill volume in tooltip by updating data attribute
                        element.dataset.backfillVolume = mapping.transferVolume;
                    }
                });

            }
        }

        // Add the function to rename plates
        function promptRenamePlate(type, number) {
            // Get current name
            const currentName = plates[type].plates[number].name || `Plate ${number}`;
            
            // Prompt for new name
            const newName = prompt(`Enter new name for ${currentName}:`, currentName);
            
            // Update if not cancelled and not empty
            if (newName !== null && newName.trim() !== '') {
                // Update name
                plates[type].plates[number].name = newName.trim();
                
                // Update mappings that reference this plate
                mappings.forEach(mapping => {
                    if ((type === 'source' && mapping.sourcePlate === number) ||
                        (type === 'destination' && mapping.destinationPlate === number)) {
                        mapping.plateName = newName.trim();
                    }
                });
                
                // Update UI
                updatePlateTabs(type);
                updateWellAttributesTables();
            }
        }
    
        // ----- WELL SELECTION & MAPPING -----
        
        // Toggle well selection
        function toggleWellSelection(wellElement, wellId, plateId) {
            const fullWellId = `${plateId}_${wellId}`;
            const isSourcePlate = plateId === 'source-plate';
            
            // Get the right array of selected wells
            let selectedWells = isSourcePlate ? selectedSourceWells : selectedDestinationWells;
            
            // Check if already selected
            const isSelected = selectedWells.includes(fullWellId);
            
            // ALWAYS handle unselection first (this makes it very reliable)
            if (isSelected) {
                // Remove from selected array
                const index = selectedWells.indexOf(fullWellId);
                selectedWells.splice(index, 1);
                
                // Remove visual selection
                wellElement.classList.remove('selected');
                
                // Update buttons
                updateMapButton();
                updateApplyBackfillButton();
                return;
            }
            
            // Clear previous active compound highlighting
            document.querySelectorAll('.active-compound').forEach(el => {
                el.classList.remove('active-compound');
            });
            
            // FROM HERE ON IS SELECTION LOGIC
            
            // Auto-detect compound ID and data from source well
            if (isSourcePlate) {
                // FIRST CHECK: Look in sourceWellDataStore (for imported data)
                const currentPlate = plates.source.active;
                const wellKey = `${currentPlate}-${wellId}`;
                
                if (window.sourceWellDataStore[wellKey]) {
                    const wellData = window.sourceWellDataStore[wellKey];
                    compoundID = wellData.compoundID;
                    document.getElementById("map-button").disabled = false;
                    wellElement.classList.add('active-compound');
                    
                    // Update the compound ID display
                    document.getElementById('compound-id').value = compoundID;
                    
                    // Auto-fill concentration fields if available
                    if (wellData.concentration) {
                        document.getElementById('source-concentration').value = wellData.concentration;
                        
                        // Set unit if available
                        const unit = wellData.unit || 'mM';
                        document.getElementById('source-concentration-unit').value = unit;
                        
                        // Store concentration data
                        window.compoundSettings[compoundID] = {
                            ...window.compoundSettings[compoundID],
                            concentration: wellData.concentration,
                            concentrationUnit: unit
                        };
                        
                        // Recalculate transfer volume if destination concentration is set
                        if (document.getElementById('destination-concentration').value && 
                            document.getElementById('final-volume').value) {
                            calculateTransferVolume();
                        }
                    }
                    
                    // Add the well to selectedSourceWells
                    selectedWells.push(fullWellId);
                    wellElement.classList.add('selected');
                    
                    updateMapButton();
                    updateApplyBackfillButton();
                    return;
                }
                
                // SECOND CHECK: Look in mappings (original behavior)
                const mapping = mappings.find(m => {
                    const wells = parseWellRange(m.source);
                    return m.sourcePlate === plates.source.active && wells.includes(wellId);
                });
                
                if (mapping) {
                    compoundID = mapping.compoundID;
                    document.getElementById("map-button").disabled = false;
                    wellElement.classList.add('active-compound');
                    
                    // Update the compound ID display
                    document.getElementById('compound-id').value = compoundID;
                    
                    // Store this compound's color for later use
                    if (mapping.color) {
                        window.compoundSettings[compoundID] = {
                            ...window.compoundSettings[compoundID],
                            color: mapping.color
                        };
                    }
                    
                    // Auto-fill concentration fields if available
                    if (mapping.concentration) {
                        document.getElementById('source-concentration').value = mapping.concentration;
                        
                        // Set unit if available
                        const unit = mapping.concentrationUnit || 'mM';
                        document.getElementById('source-concentration-unit').value = unit;
                        
                        // Store concentration data
                        window.compoundSettings[compoundID] = {
                            ...window.compoundSettings[compoundID],
                            concentration: mapping.concentration,
                            concentrationUnit: unit
                        };
                        
                        // Recalculate transfer volume if destination concentration is set
                        if (document.getElementById('destination-concentration').value && 
                            document.getElementById('final-volume').value) {
                            calculateTransferVolume();
                        }
                    }
                    
                    // Add the well to selectedSourceWells
                    selectedWells.push(fullWellId);
                    wellElement.classList.add('selected');
                    
                    updateMapButton();
                    updateApplyBackfillButton();
                    return;
                }
                
                // THIRD CHECK: Check for diluted source wells
                const dilutedMapping = mappings.find(m => 
                    (m.type === "DILUTED_SOURCE" || m.isDilutedSource) && 
                    m.destinationPlate === plates.source.active && 
                    m.destination === wellId
                );
                
                if (dilutedMapping) {
                    compoundID = dilutedMapping.originalCompoundID || dilutedMapping.compoundID.replace(' (Diluted)', '');
                    document.getElementById("map-button").disabled = false;
                    wellElement.classList.add('active-compound');
                    
                    // Update the compound ID display
                    document.getElementById('compound-id').value = compoundID;
                    
                    // Auto-fill concentration fields with diluted concentration
                    if (dilutedMapping.dilutedConcentration) {
                        document.getElementById('source-concentration').value = dilutedMapping.dilutedConcentration;
                        
                        // Set unit if available
                        const unit = dilutedMapping.sourceUnit || 'mM';
                        document.getElementById('source-concentration-unit').value = unit;
                    }
                    
                    // Add the well to selectedSourceWells
                    selectedWells.push(fullWellId);
                    wellElement.classList.add('selected');
                    
                    updateMapButton();
                    updateApplyBackfillButton();
                    return;
                }
                
                // FOURTH CHECK: Check for backfiller wells
                const backfillerMapping = mappings.find(m => 
                    m.type === "BACKFILL_SOURCE" && 
                    m.destinationPlate === plates.source.active && 
                    m.destination === wellId
                );
                
                if (backfillerMapping) {
                    // Just select the well without changing compound ID
                    selectedWells.push(fullWellId);
                    wellElement.classList.add('selected');
                    
                    updateMapButton();
                    updateApplyBackfillButton();
                    return;
                }
            }

            // Default behavior for normal well selection
            selectedWells.push(fullWellId);
            wellElement.classList.add('selected');

            updateMapButton();
            updateApplyBackfillButton();
        }
    
        // Get well info for tooltips
        function getWellInfo(wellElement, plateId) {
            const wellId = wellElement.id.split('_')[1];
            const isSource = plateId === 'source-plate';
            const plateNumber = plates[isSource ? 'source' : 'destination'].active;
            
            // SOURCE PLATE TOOLTIPS
            if (isSource) {
                // First check if this is a backfiller source well
                const backfillerMapping = mappings.find(m => 
                    m.type === "BACKFILL_SOURCE" && 
                    m.destinationPlate === plateNumber && 
                    m.destination === wellId
                );
                
                if (backfillerMapping) {
                    return `Backfill Source\nLiquid: ${backfillerMapping.compoundID}\nWell: ${wellId}`;
                }
                
                // Check if this is a diluted source well with enhanced info
                const dilutedSourceMapping = mappings.find(m => 
                    (m.type === "DILUTED_SOURCE" || m.isDilutedSource) && 
                    m.destinationPlate === plateNumber && 
                    m.destination === wellId
                );

                if (dilutedSourceMapping) {
                    // Enhanced information for diluted source well
                    const concValue = dilutedSourceMapping.dilutedConcentration;
                    const unit = dilutedSourceMapping.sourceUnit || 'µM';
                    
                    // Get the original compound ID without the diluted suffix
                    const originalCompound = dilutedSourceMapping.originalCompoundID || 
                        dilutedSourceMapping.compoundID.replace(/ \([^)]+\)$/, '');
                    
                    // Get the source well(s) this was derived from
                    const sourceWellInfo = dilutedSourceMapping.source ? 
                        `Source: ${dilutedSourceMapping.source.replace(/[{}]/g, '')}` : '';
                    
                    // Build enhanced tooltip
                    const tooltip = [
                        `❕ DILUTED SOURCE WELL`,
                        `Compound: ${originalCompound}`,
                        `Well: ${wellId}`,
                        `Concentration: ${concValue} ${unit}`,
                        `Dilution Factor: ${dilutedSourceMapping.dilutionFactor}x`
                    ];
                    
                    // Add source well info if available
                    if (sourceWellInfo) {
                        tooltip.push(sourceWellInfo);
                    }
                    
                    // Add info about plates if different from current
                    if (dilutedSourceMapping.sourcePlate !== plateNumber) {
                        const sourcePlateName = plates.source.plates[dilutedSourceMapping.sourcePlate]?.name || 
                            `Plate ${dilutedSourceMapping.sourcePlate}`;
                        tooltip.push(`From plate: ${sourcePlateName}`);
                    }
                    
                    return tooltip.join('\n');
                }
                
                // Check source well data store for well-specific concentration
                const wellDataKey = `${plateNumber}-${wellId}`;
                if (window.sourceWellDataStore && window.sourceWellDataStore[wellDataKey]) {
                    const wellData = window.sourceWellDataStore[wellDataKey];
                    
                    const plateName = plates['source'].plates[plateNumber].name || `Plate ${plateNumber}`;
                    return `Compound: ${wellData.compoundID}\n` +
                        `Well: ${wellId}\n` +
                        `Source Plate: ${plateName}\n` +
                        `Concentration: ${wellData.concentration} ${wellData.unit}`;
                }
                
                // Fall back to checking mappings
                const sourceMappings = mappings.filter(m => 
                    !m.type && // Not a typed mapping
                    !m.isDilutedSource && // Not a diluted source
                    m.sourcePlate === plateNumber && 
                    parseWellRange(m.source).includes(wellId)
                );
                
                if (sourceMappings.length > 0) {
                    // Group by compound to avoid duplication
                    const compoundGroups = {};
                    
                    sourceMappings.forEach(mapping => {
                        if (!compoundGroups[mapping.compoundID]) {
                            compoundGroups[mapping.compoundID] = [];
                        }
                        compoundGroups[mapping.compoundID].push(mapping);
                    });
                    
                    // Build tooltip for each compound group (only once per compound)
                    const tooltips = Object.entries(compoundGroups).map(([compound, mappings]) => {
                        // Use the first mapping for this compound
                        const mapping = mappings[0];
                        
                        const plateName = plates.source.plates[plateNumber].name || `Plate ${plateNumber}`;
                        let tooltip = `Compound: ${compound}\nWell: ${wellId}\nSource Plate: ${plateName}`;
                        
                        // Check for concentration values
                        let concentrationValue = null;
                        let concentrationUnit = 'mM'; // Default unit
                        
                        if (mapping.sourceConcentration) {
                            concentrationValue = mapping.sourceConcentration;
                            concentrationUnit = mapping.sourceUnit || 'mM';
                        } else if (mapping.concentration) {
                            concentrationValue = mapping.concentration;
                            concentrationUnit = mapping.concentrationUnit || 'mM';
                        }
                        
                        // Add concentration to tooltip
                        if (concentrationValue !== null) {
                            tooltip += `\nConcentration: ${concentrationValue} ${concentrationUnit}`;
                        } else {
                            tooltip += "\nConcentration: unknown";
                        }
                        
                        return tooltip;
                    });
                    
                    return tooltips.join('\n\n');
                }
                
                return null; // Not a mapped well
            }
            
            // DESTINATION PLATE TOOLTIPS
            else {
                // Get ALL mappings for this well, including backfill
                const tooltipParts = [];
                
                // 1. Check for compound mappings
                const destinationMappings = mappings.filter(m => 
                    (m.type === "DESTINATION" || (!m.type && !m.isDilutedSource)) && // Include legacy
                    m.destinationPlate === plateNumber && 
                    m.destination === wellId
                );
                
                // 2. Check for backfill mappings
                const backfillMappings = mappings.filter(m => 
                    m.type === "BACKFILL" && 
                    m.destinationPlate === plateNumber && 
                    m.destination === wellId
                );
                
                if (destinationMappings.length === 0 && backfillMappings.length === 0) {
                    return null;
                }
                
                // Add compound info, but only show destination concentration
                destinationMappings.forEach(mapping => {
                    const sourcePlateName = plates.source.plates[mapping.sourcePlate] ? 
                        plates.source.plates[mapping.sourcePlate].name : `Plate ${mapping.sourcePlate}`;

                    const info = [
                        `Compound: ${mapping.compoundID}`,
                        `Source Well: ${mapping.source.replace(/[{}]/g, '')}`,
                        `Source Plate: ${sourcePlateName}`,
                        `Transfer Volume: ${mapping.transferVolume} nL`
                    ];

                    // Check different sources for concentration information
                    let concentrationValue = null;
                    let concentrationUnit = 'µM'; // Default unit
                    
                    if (mapping.destinationConcentration) {
                        concentrationValue = mapping.destinationConcentration;
                        concentrationUnit = mapping.destinationUnit || 'µM';
                    } else if (mapping.expectedConcentration) {
                        concentrationValue = mapping.expectedConcentration;
                        concentrationUnit = 'µM';
                    } 
                    
                    // Add concentration info to tooltip
                    if (concentrationValue !== null) {
                        info.push(`Desired Concentration: ${concentrationValue} ${concentrationUnit}`);
                        
                        // Calculate and add actual concentration based on rounded transfer volume
                        // Extract required values for actual concentration calculation
                        const transferVolume = parseFloat(mapping.transferVolume); // nL
                        const finalVolume = parseFloat(mapping.finalVolume) || 0; // µL
                        let sourceConc = 0;
                        let sourceUnit = 'µM';
                        
                        // Get source concentration from different possible locations
                        if (mapping.sourceConcentration) {
                            sourceConc = parseFloat(mapping.sourceConcentration);
                            sourceUnit = mapping.sourceUnit || 'µM';
                        } else if (mapping.sourceConcInMicroMolar) {
                            sourceConc = parseFloat(mapping.sourceConcInMicroMolar);
                            sourceUnit = 'µM';
                        }
                        
                        // Calculate actual concentration only if we have all required values
                        if (transferVolume > 0 && finalVolume > 0 && sourceConc > 0) {
                            // Convert source concentration to µM for calculation
                            let sourceConcInMicroMolar = sourceConc;
                            if (sourceUnit === 'mM') {
                                sourceConcInMicroMolar = sourceConc * 1000;
                            } else if (sourceUnit === 'nM') {
                                sourceConcInMicroMolar = sourceConc / 1000;
                            }
                            
                            // Calculate actual concentration in µM
                            const actualConcInMicroMolar = (transferVolume / 1000) * sourceConcInMicroMolar / finalVolume;
                            
                            // Convert back to desired unit
                            let actualConc = actualConcInMicroMolar;
                            if (concentrationUnit === 'mM') {
                                actualConc = actualConcInMicroMolar / 1000;
                            } else if (concentrationUnit === 'nM') {
                                actualConc = actualConcInMicroMolar * 1000;
                            }
                            
                            // Add to tooltip with higher precision
                            info.push(`Actual Concentration: ${actualConc.toFixed(4)} ${concentrationUnit}`);
                            
                            // Add percent difference if desired concentration available
                            if (concentrationValue > 0) {
                                const percentDiff = ((actualConc - concentrationValue) / concentrationValue) * 100;
                                info.push(`Difference: ${percentDiff.toFixed(2)}%`);
                            }

                            // Add diluent information if available (after the concentration difference)
                            if (mapping.diluentType && mapping.diluentPercent) {
                                info.push(`${mapping.diluentType}: ${mapping.diluentPercent}%`);
                                
                                // Add warning if diluent limit was exceeded
                                if (mapping.diluentLimitExceeded) {
                                    info.push(`⚠️ ${mapping.diluentType} limit affected concentration`);
                                }
                            }
                        }
                    } else {
                        info.push(`Concentration: unknown`);
                    }
                    
                    tooltipParts.push(info.join('\n'));
                });
                
                // Add backfill info with better formatting
                backfillMappings.forEach(mapping => {
                    const backfillType = mapping.backfillType || mapping.compoundID;
                    
                    const info = [
                        `Backfill: ${backfillType}`,
                        `Source Well: ${mapping.source.replace(/[{}]/g, '')}`,
                        `Transfer Volume: ${mapping.transferVolume} nL`
                    ];
                    
                    tooltipParts.push(info.join('\n'));
                });
                
                return tooltipParts.join('\n\n');
            }
        }
    
        // Calculate transfer volume based on concentrations
        function calculateTransferVolume() {
            const sourceConc = parseFloat(document.getElementById('source-concentration').value);
            const sourceUnit = document.getElementById('source-concentration-unit').value;
            const destConc = parseFloat(document.getElementById('destination-concentration').value);
            const destUnit = document.getElementById('destination-concentration-unit').value;
            const finalVolume = parseFloat(document.getElementById('final-volume').value);
            
            if (sourceConc && destConc && finalVolume) {
                // Convert all to µM for calculation
                const sourceConcInMicroMolar = convertToMicroMolar(sourceConc, sourceUnit);
                const destConcInMicroMolar = convertToMicroMolar(destConc, destUnit);
                
                if (sourceConcInMicroMolar < destConcInMicroMolar) {
                    alert('Error: Source concentration must be higher than destination concentration (after unit conversion)');
                    return;
                }
                
                // Calculate and round transfer volume
                const transferVolumeUL = (destConcInMicroMolar * finalVolume) / sourceConcInMicroMolar;
                const transferVolumeNL = roundToEchoIncrement(transferVolumeUL * 1000);
                
                document.getElementById('transfer-volume').value = transferVolumeNL.toFixed(2);
                
                // Update diluent volume display
                const diluentVolume = finalVolume - (transferVolumeNL / 1000);
                document.getElementById('diluent-volume').textContent = diluentVolume.toFixed(2);
            }
        }
    
        // Update diluent volume from transfer volume
        function updateDiluentVolume(transferVolumeUL, finalVolume) {
            if (!isNaN(transferVolumeUL) && !isNaN(finalVolume)) {
                // Calculate diluent volume in µL
                const diluentVolume = finalVolume - transferVolumeUL;
                document.getElementById('diluent-volume').textContent = diluentVolume.toFixed(2);
            } else {
                document.getElementById('diluent-volume').textContent = '0.00';
            }
        }
    
        // Function to create and update well attribute tables
        function createWellAttributesTables() {
            // Only create if they don't already exist
            if (document.querySelector('.attributes-table-container')) {
                return;
            }
            
            // First, add the necessary CSS styles for highlighting
            const styleElement = document.createElement('style');
            styleElement.textContent = `
                .highlighted-from-table {
                    outline: 3px solid #ff4500 !important; /* Bright orange outline */
                    outline-offset: -1px;
                    box-shadow: 0 0 10px #ff4500;
                    z-index: 10;
                    position: relative;
                }

                .table-row-selected {
                    background-color: #e0f0ff !important; /* Light blue background */
                    outline: 2px solid #4682b4;
                }

                .attributes-table-container tbody tr {
                    cursor: pointer;
                    transition: background-color 0.2s;
                }
                
                .attributes-table-container tbody tr:hover {
                    background-color: #f5f5f5;
                }
                
                /* Make tables more compact with fixed header */
                .source-attributes-table, .destination-attributes-table {
                    max-height: 300px;
                    overflow-y: auto;
                    margin-bottom: 20px;
                    border: 1px solid #ddd;
                    border-radius: 4px;
                }
                
                .attributes-table-container h3 {
                    background-color: #f8f9fa;
                    margin: 0;
                    padding: 10px;
                    border-bottom: 1px solid #ddd;
                    position: sticky;
                    top: 0;
                    z-index: 5;
                }
                
                .attributes-table-container table {
                    width: 100%;
                    border-collapse: collapse;
                }
                
                .attributes-table-container th {
                    background-color: #f8f9fa;
                    position: sticky;
                    top: 43px; /* Position below the h3 header */
                    z-index: 5;
                }
                
                /* Added CSS for multi-line text display */
                .attributes-table-container td {
                    white-space: pre-line; /* Allow line breaks within cells */
                    vertical-align: top;   /* Align text to top of cell */
                    max-width: 200px;      /* Prevent cells from getting too wide */
                    word-wrap: break-word; /* Allow long words to break */
                }
            `;
            document.head.appendChild(styleElement);
            
            // Create table container
            const tableContainer = document.createElement('div');
            tableContainer.className = 'attributes-table-container';
            tableContainer.style.cssText = 'margin-top: 20px; display: flex; flex-wrap: wrap; gap: 20px;';
            
            // Create source wells table
            const sourceTable = document.createElement('div');
            sourceTable.className = 'source-attributes-table';
            sourceTable.style.cssText = 'flex: 1; min-width: 300px; max-height: 300px; overflow-y: auto;';
            sourceTable.innerHTML = '<h3>Source Wells Attributes</h3>';
            
            // Create table element
            const sourceTableElement = document.createElement('table');
            sourceTableElement.style.cssText = 'width: 100%; border-collapse: collapse;';
            sourceTableElement.innerHTML = `
                <thead>
                    <tr>
                        <th style="padding: 8px; border: 1px solid #ddd; text-align: left;">Well</th>
                        <th style="padding: 8px; border: 1px solid #ddd; text-align: left;">Compound ID</th>
                        <th style="padding: 8px; border: 1px solid #ddd; text-align: left;">Concentration</th>
                        <th style="padding: 8px; border: 1px solid #ddd; text-align: left;">Type</th>
                        <th style="padding: 8px; border: 1px solid #ddd; text-align: left;">Notes</th>
                    </tr>
                </thead>
                <tbody id="source-attributes-tbody">
                </tbody>
            `;
            sourceTable.appendChild(sourceTableElement);
            
            // Create destination wells table
            const destTable = document.createElement('div');
            destTable.className = 'destination-attributes-table';
            destTable.style.cssText = 'flex: 1; min-width: 300px; max-height: 300px; overflow-y: auto;';
            destTable.innerHTML = '<h3>Destination Wells Attributes</h3>';
            
            // Create table element
            const destTableElement = document.createElement('table');
            destTableElement.style.cssText = 'width: 100%; border-collapse: collapse;';
            destTableElement.innerHTML = `
                <thead>
                    <tr>
                        <th style="padding: 8px; border: 1px solid #ddd; text-align: left;">Well</th>
                        <th style="padding: 8px; border: 1px solid #ddd; text-align: left;">Compound ID</th>
                        <th style="padding: 8px; border: 1px solid #ddd; text-align: left;">Source</th>
                        <th style="padding: 8px; border: 1px solid #ddd; text-align: left;">Concentration</th>
                        <th style="padding: 8px; border: 1px solid #ddd; text-align: left;">Transfer Vol</th>
                    </tr>
                </thead>
                <tbody id="destination-attributes-tbody">
                </tbody>
            `;
            destTable.appendChild(destTableElement);
            
            // Add tables to container
            tableContainer.appendChild(sourceTable);
            tableContainer.appendChild(destTable);
            
            // Add to document after plate manager
            document.querySelector('.plate-manager').after(tableContainer);
            
            // Make sure tables are always visible (remove the toggle button functionality)
            tableContainer.style.display = 'flex';
            
            // Update tables immediately
            updateWellAttributesTables();
        }
    
        // Helper function to normalize well IDs (remove zero-padding)
        function normalizeWellID(wellID) {
            // Match the letter part and number part
            const match = wellID.match(/([A-Z]+)(\d+)/);
            if (!match) return wellID;
            
            // Extract row and column
            const row = match[1];
            const col = parseInt(match[2], 10); // Convert to number to remove leading zeros
            
            // Return normalized format (A1, B2, etc.)
            return `${row}${col}`;
        }
    
        // Function to update the tables content
        function updateWellAttributesTables() {
            const currentSourcePlate = plates.source.active;
            const currentDestPlate = plates.destination.active;
            
            // Get tbody elements
            const sourceTbody = document.getElementById('source-attributes-tbody');
            const destTbody = document.getElementById('destination-attributes-tbody');
            
            if (!sourceTbody || !destTbody) return;
            
            // Clear existing rows
            sourceTbody.innerHTML = '';
            destTbody.innerHTML = '';
            
            // Populate source wells table
            const sourceWells = {};  // Use an object to track by normalized well ID
            
            // Add from sourceWellDataStore
            Object.keys(window.sourceWellDataStore).forEach(key => {
                if (key.startsWith(`${currentSourcePlate}-`)) {
                    const [plateNum, wellId] = key.split('-');
                    const wellData = window.sourceWellDataStore[key];
                    
                    // Normalize the well ID
                    const normalizedWellId = normalizeWellID(wellId);
                    
                    sourceWells[normalizedWellId] = {
                        well: normalizedWellId, // Use normalized ID
                        compoundID: wellData.compoundID || '',
                        concentration: `${wellData.concentration || ''} ${wellData.unit || ''}`,
                        type: wellData.isDiluted ? 'Diluted Source' : 'Standard',
                        notes: wellData.isDiluted ? `Diluted ${wellData.dilutionFactor}x` : ''
                    };
                }
            });
            
            // Add from mappings
            mappings.forEach(mapping => {
                if (mapping.sourcePlate !== currentSourcePlate) return;
                
                // Backfiller sources
                if (mapping.type === "BACKFILL_SOURCE") {
                    const wellId = normalizeWellID(mapping.destination);
                    
                    // Update or create the well entry
                    if (sourceWells[wellId]) {
                        sourceWells[wellId].type = 'Backfiller';
                        sourceWells[wellId].notes = `Liquid: ${mapping.compoundID}`;
                    } else {
                        sourceWells[wellId] = {
                            well: wellId,
                            compoundID: mapping.compoundID || '',
                            concentration: '',
                            type: 'Backfiller',
                            notes: `Liquid: ${mapping.compoundID}`
                        };
                    }
                }
                
                // Diluted sources
                else if (mapping.type === "DILUTED_SOURCE" || mapping.isDilutedSource) {
                    const wellId = normalizeWellID(mapping.destination);
                    
                    // Update or create the well entry
                    if (sourceWells[wellId]) {
                        sourceWells[wellId].type = 'Diluted Source';
                        sourceWells[wellId].notes = `Diluted ${mapping.dilutionFactor}x`;
                    } else {
                        sourceWells[wellId] = {
                            well: wellId,
                            compoundID: mapping.compoundID || '',
                            concentration: `${mapping.dilutedConcentration || ''} ${mapping.sourceUnit || ''}`,
                            type: 'Diluted Source',
                            notes: `Diluted ${mapping.dilutionFactor}x`
                        };
                    }
                }
                
                // Regular source wells from mappings
                else if (!mapping.type && !mapping.isDilutedSource) {
                    const sourceWellList = parseWellRange(mapping.source);
                    
                    sourceWellList.forEach(wellPosition => {
                        const wellId = normalizeWellID(wellPosition);
                        
                        // Only add if not already exists
                        if (!sourceWells[wellId]) {
                            sourceWells[wellId] = {
                                well: wellId,
                                compoundID: mapping.compoundID || '',
                                concentration: `${mapping.concentration || mapping.sourceConcentration || ''} ${mapping.concentrationUnit || mapping.sourceUnit || ''}`,
                                type: 'Standard',
                                notes: ''
                            };
                        }
                    });
                }
            });
            
            // Convert the object to an array for sorting
            const sourceWellsArray = Object.values(sourceWells);
            
            // Sort wells by position
            sourceWellsArray.sort((a, b) => {
                const aRow = a.well.match(/[A-Z]+/)[0];
                const bRow = b.well.match(/[A-Z]+/)[0];
                const aCol = parseInt(a.well.match(/\d+/)[0]);
                const bCol = parseInt(b.well.match(/\d+/)[0]);
                
                if (aRow === bRow) {
                    return aCol - bCol;
                }
                return aRow.localeCompare(bRow);
            });
            
            // Add rows to source table with click events for well highlighting
            sourceWellsArray.forEach(well => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td style="padding: 8px; border: 1px solid #ddd;">${well.well}</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">${well.compoundID}</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">${well.concentration}</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">${well.type}</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">${well.notes}</td>
                `;
                
                // Add click event to highlight the corresponding well in the plate
                row.addEventListener('click', () => {
                    // Get the well element - try both formats to be safe
                    let wellElement = document.getElementById(`source-plate_${well.well}`);
                    
                    // If not found with the normalized format, try with zero-padded format
                    if (!wellElement) {
                        const match = well.well.match(/([A-Z]+)(\d+)/);
                        if (match) {
                            const row = match[1];
                            const col = match[2].padStart(2, '0');
                            wellElement = document.getElementById(`source-plate_${row}${col}`);
                        }
                    }
                    
                    // Clear all highlighted wells first
                    document.querySelectorAll('.highlighted-from-table').forEach(el => {
                        el.classList.remove('highlighted-from-table');
                    });
                    
                    // Clear all highlighted rows
                    document.querySelectorAll('.table-row-selected').forEach(el => {
                        el.classList.remove('table-row-selected');
                    });
                    
                    // Highlight this row
                    row.classList.add('table-row-selected');
                    
                    // Highlight the well if found
                    if (wellElement) {
                        wellElement.classList.add('highlighted-from-table');
                        // Ensure the well is visible
                        wellElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                });
                
                sourceTbody.appendChild(row);
            });
            
            // UPDATED PART: New approach for destination wells to show all mappings

            // Group mappings by well ID
            const destWellGroups = {};  // Group mappings by well ID

            // Group all mappings by destination well
            mappings.forEach(mapping => {
                if (mapping.destinationPlate !== currentDestPlate) return;
                
                // Normalize the well ID
                const wellId = normalizeWellID(mapping.destination);
                
                if (!destWellGroups[wellId]) {
                    destWellGroups[wellId] = [];
                }
                
                destWellGroups[wellId].push(mapping);
            });

            // Process each well with all its mappings
            const destWellsArray = [];
            Object.entries(destWellGroups).forEach(([wellId, wellMappings]) => {
                // Separate compound mappings and backfill mappings
                const compoundMappings = wellMappings.filter(m => !m.type || m.type === "DESTINATION");
                const backfillMappings = wellMappings.filter(m => m.type === "BACKFILL" || m.isBackfill);
                
                // Combine all mappings information
                const wellData = {
                    well: wellId,
                    compoundInfo: compoundMappings.map(m => {
                        let concValue = m.destinationConcentration || m.expectedConcentration || '';
                        if (typeof concValue === 'number') {
                            concValue = parseFloat(concValue.toFixed(4));
                        }
                        return {
                            compoundID: m.compoundID || '',
                            source: m.source ? m.source : '',
                            concentration: `${concValue} ${m.destinationUnit || 'µM'}`,
                            transferVol: `${m.transferVolume || ''} nL`
                        };
                    }),
                    backfillInfo: backfillMappings.map(m => ({
                        compoundID: `${m.compoundID} (Backfill)`,
                        source: m.source ? m.source : '',
                        concentration: '',  // No concentration for backfill
                        transferVol: `${m.transferVolume || ''} nL`
                    }))
                };
                
                // Combine all info into a single row with separated lines
                destWellsArray.push({
                    well: wellId,
                    compoundID: [...wellData.compoundInfo.map(i => i.compoundID), 
                                ...wellData.backfillInfo.map(i => i.compoundID)].join('\n'),
                    source: [...wellData.compoundInfo.map(i => i.source),
                            ...wellData.backfillInfo.map(i => i.source)].join('\n'),
                    concentration: [...wellData.compoundInfo.map(i => i.concentration),
                                ...wellData.backfillInfo.map(i => i.concentration)].join('\n'),
                    transferVol: [...wellData.compoundInfo.map(i => i.transferVol),
                                ...wellData.backfillInfo.map(i => i.transferVol)].join('\n')
                });
            });

            // Sort destination wells
            destWellsArray.sort((a, b) => {
                const aRow = a.well.match(/[A-Z]+/)[0];
                const bRow = b.well.match(/[A-Z]+/)[0];
                const aCol = parseInt(a.well.match(/\d+/)[0]);
                const bCol = parseInt(b.well.match(/\d+/)[0]);
                
                if (aRow === bRow) {
                    return aCol - bCol;
                }
                return aRow.localeCompare(bRow);
            });
            
            // Add rows to destination table with click events for well highlighting
            destWellsArray.forEach(well => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td style="padding: 8px; border: 1px solid #ddd; white-space: pre-line;">${well.well}</td>
                    <td style="padding: 8px; border: 1px solid #ddd; white-space: pre-line;">${well.compoundID}</td>
                    <td style="padding: 8px; border: 1px solid #ddd; white-space: pre-line;">${well.source}</td>
                    <td style="padding: 8px; border: 1px solid #ddd; white-space: pre-line;">${well.concentration}</td>
                    <td style="padding: 8px; border: 1px solid #ddd; white-space: pre-line;">${well.transferVol}</td>
                `;
                
                // Add click event to highlight the corresponding well in the plate
                row.addEventListener('click', () => {
                    // Get the well element - try both formats to be safe
                    let wellElement = document.getElementById(`destination-plate_${well.well}`);
                    
                    // If not found with the normalized format, try with zero-padded format
                    if (!wellElement) {
                        const match = well.well.match(/([A-Z]+)(\d+)/);
                        if (match) {
                            const row = match[1];
                            const col = match[2].padStart(2, '0');
                            wellElement = document.getElementById(`destination-plate_${row}${col}`);
                        }
                    }
                    
                    // Clear all highlighted wells first
                    document.querySelectorAll('.highlighted-from-table').forEach(el => {
                        el.classList.remove('highlighted-from-table');
                    });
                    
                    // Clear all highlighted rows
                    document.querySelectorAll('.table-row-selected').forEach(el => {
                        el.classList.remove('table-row-selected');
                    });
                    
                    // Highlight this row
                    row.classList.add('table-row-selected');
                    
                    // Highlight the well if found
                    if (wellElement) {
                        wellElement.classList.add('highlighted-from-table');
                        // Ensure the well is visible
                        wellElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                });
                
                destTbody.appendChild(row);
            });
        }
    
        // Add hooks to update tables when plate displays are refreshed
        const originalRefreshPlateDisplay = refreshPlateDisplay;
        refreshPlateDisplay = function(type) {
            originalRefreshPlateDisplay(type);
            if (typeof updateWellAttributesTables === 'function') {
                updateWellAttributesTables();
            }
        };
    
        // Initialize tables
        document.addEventListener('DOMContentLoaded', function() {
            createWellAttributesTables();
        });
    
        // ----- MAPPING FUNCTIONS -----
        
        // Create a mapping between selected source and destination wells
        function createMapping() {
            saveStateForUndo('mapping', { sourceWells: selectedSourceWells, destWells: selectedDestinationWells });

            
            if (selectedSourceWells.length === 0 || selectedDestinationWells.length === 0) {
                alert('Please select at least one source well and one destination well.');
                return;
            }
            
            if (!compoundID) {
                alert("Set a Compound ID before mapping wells.");
                return;
            }
    
            // Get mapping parameters
            const mappingColor = getCompoundColor(compoundID);
            const rawTransferVolume = parseFloat(document.getElementById('transfer-volume').value) || 0;
            const transferVolume = roundToEchoIncrement(rawTransferVolume);
            const sourcePlate = plates.source.active;
            const destinationPlate = plates.destination.active;
            
            // Get concentration values
            const sourceConc = parseFloat(document.getElementById('source-concentration').value);
            const sourceUnit = document.getElementById('source-concentration-unit').value;
            const destConc = parseFloat(document.getElementById('destination-concentration').value);
            const destUnit = document.getElementById('destination-concentration-unit').value;
            const finalVolume = parseFloat(document.getElementById('final-volume').value);
            
            // Convert source wells to the range format
            const sourceWellPositions = selectedSourceWells.map(wellId => wellId.split('_')[1]);
            const sourceWellsRange = convertWellsToRange(sourceWellPositions);
            
            // Create a source mapping
            mappings.push({
                sourcePlate: sourcePlate,
                source: sourceWellsRange,
                compoundID: compoundID,
                color: mappingColor,
                concentration: !isNaN(sourceConc) ? sourceConc : null,
                concentrationUnit: sourceUnit,
                sourceConcentration: !isNaN(sourceConc) ? sourceConc : null,
                sourceUnit: sourceUnit
            });
            
            // If source concentration is provided, store in data store
            if (!isNaN(sourceConc)) {
                // Store for each selected source well
                sourceWellPositions.forEach(wellPosition => {
                    const wellKey = `${sourcePlate}-${wellPosition}`;
                    
                    // Check if this well already has stored data
                    if (!window.sourceWellDataStore[wellKey]) {
                        window.sourceWellDataStore[wellKey] = {
                            concentration: sourceConc,
                            unit: sourceUnit,
                            compoundID: compoundID
                        };
                    }
                });
            }
            
            // Create destination mappings
            selectedDestinationWells.forEach(destinationWellId => {
                const destinationWell = destinationWellId.split('_')[1];
    
                mappings.push({
                    sourcePlate,
                    destinationPlate,
                    source: sourceWellsRange,
                    destination: destinationWell,
                    transferVolume: transferVolume.toFixed(2),
                    compoundID,
                    color: mappingColor,
                    sourceConcentration: !isNaN(sourceConc) ? sourceConc : null,
                    sourceUnit: sourceUnit,
                    destinationConcentration: !isNaN(destConc) ? destConc : null,
                    destinationUnit: destUnit,
                    finalVolume: !isNaN(finalVolume) ? finalVolume : null
                });
            });
    
            // Update UI
            refreshPlateDisplay('source');
            refreshPlateDisplay('destination');
            
            // Clear selections
            selectedSourceWells = [];
            selectedDestinationWells = [];
            document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
            
            // Update buttons
            updateMapButton();
            updateSaveButton();
            updateApplyBackfillButton();
            
            // Update compound list if it exists
            if (typeof updateCompoundList === 'function') {
                updateCompoundList();
            }
        }
    
        // Apply backfilling to destination wells
        function applyBackfill() {
            saveStateForUndo('backfill', { sourceWells: selectedSourceWells, destWells: selectedDestinationWells });
            // Validate selections
            if (selectedSourceWells.length === 0) {
                alert('Please select at least one source well containing the backfill liquid');
                return;
            }
            
            if (selectedDestinationWells.length === 0) {
                alert('Please select at least one destination well to receive the backfill');
                return;
            }
            
            // Get backfill parameters
            const backfillLiquid = document.getElementById('backfill-liquid-selector').value;
            const targetTotalVolume = parseFloat(document.getElementById('backfill-volume').value);
            
            // Validate target volume
            if (isNaN(targetTotalVolume) || targetTotalVolume < 2.5) {
                alert('Please enter a valid target volume (minimum 2.5 nL)');
                return;
            }
            
            // Get plate information
            const sourcePlate = plates.source.active;
            const destinationPlate = plates.destination.active;
            
            // Get well positions
            const sourceWellPositions = selectedSourceWells.map(id => id.split('_')[1]);
            const destWellPositions = selectedDestinationWells.map(id => id.split('_')[1]);
            
            // FIXED: Instead of removing all backfill source mappings at once, do it per well
            // This allows accumulating backfiller wells across different operations
            sourceWellPositions.forEach(wellPosition => {
                // Remove only the backfill mapping for this specific well
                mappings = mappings.filter(m => 
                    !(m.type === "BACKFILL_SOURCE" && 
                    m.sourcePlate === sourcePlate && 
                    m.destinationPlate === sourcePlate &&
                    m.destination === wellPosition) // Only remove this specific well
                );
                
                // Add the new backfill marking for this well
                mappings.push({
                    type: "BACKFILL_SOURCE",
                    sourcePlate: sourcePlate,
                    destinationPlate: sourcePlate, // Marked in source plate
                    source: `{${wellPosition}}`,
                    destination: wellPosition,
                    transferVolume: "0", // No actual transfer for this marker
                    compoundID: backfillLiquid,
                    color: 'rgba(128, 128, 128, 0.7)' // Gray for backfill
                });
            });
            
            // Convert source wells to range format for the mapping
            const sourceWellsRange = convertWellsToRange(sourceWellPositions);
            
            // Track the number of wells actually backfilled
            let backfilledCount = 0;
            
            // Create backfill mappings for each destination well
            destWellPositions.forEach(destWell => {
                // Calculate existing volume in this well by summing all compound volumes
                let existingVolume = 0;
                
                // Find all mappings for this destination well (excluding backfill)
                const wellMappings = mappings.filter(m => 
                    m.destinationPlate === destinationPlate && 
                    m.destination === destWell && 
                    !(m.type === "BACKFILL" || m.isBackfill)
                );
                
                // Sum up volumes
                wellMappings.forEach(mapping => {
                    const volume = parseFloat(mapping.transferVolume);
                    if (!isNaN(volume)) {
                        existingVolume += volume;
                    }
                });
                
                // Calculate backfill volume needed to reach target total
                const backfillVolume = targetTotalVolume - existingVolume;
                const roundedBackfillVolume = roundToEchoIncrement(Math.max(0, backfillVolume));
                
                console.log(`Well ${destWell}: Existing ${existingVolume} nL, Need ${roundedBackfillVolume} nL of backfill to reach ${targetTotalVolume} nL total`);
                
                // Only add if backfill volume is at least minimum Echo volume
                if (roundedBackfillVolume >= 2.5) {
                    // First remove any existing backfill for this specific destination well
                    mappings = mappings.filter(m => 
                        !(m.type === "BACKFILL" && 
                        m.destinationPlate === destinationPlate &&
                        m.destination === destWell)
                    );
                    
                    // Then add the new backfill mapping
                    mappings.push({
                        type: "BACKFILL",
                        sourcePlate: sourcePlate,
                        destinationPlate: destinationPlate,
                        source: sourceWellsRange,
                        destination: destWell,
                        transferVolume: roundedBackfillVolume.toFixed(2),
                        compoundID: backfillLiquid,
                        color: 'rgba(128, 128, 128, 0.3)', // Light gray for backfill
                        isBackfill: true
                    });
                    backfilledCount++;
                } else if (roundedBackfillVolume > 0) {
                    console.warn(`Skipping backfill for ${destWell}: volume ${roundedBackfillVolume} nL is below minimum 2.5 nL`);
                } else if (existingVolume >= targetTotalVolume) {
                    console.warn(`Skipping backfill for ${destWell}: already contains ${existingVolume} nL (target: ${targetTotalVolume} nL)`);
                }
            });
            
            // Refresh displays
            refreshPlateDisplay('source');
            refreshPlateDisplay('destination');
            
            // Clear selections
            selectedSourceWells = [];
            selectedDestinationWells = [];
            document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
            
            // Update UI
            updateMapButton();
            updateSaveButton();
            updateApplyBackfillButton();
        }

        // ----- SERIAL DILUTION FUNCTIONS -----
        
        // Prepare serial dilution modal
        function prepareSerialDilutionModal() {
            // Clear any previous selections for backfiller wells
            selectedSourceWells = []; 
            document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
            
            // Reset backfill liquid selector to default
            const backfillSelector = document.getElementById('serial-backfill-fluid');
            if (backfillSelector) {
                backfillSelector.value = 'DMSO'; // Default to DMSO
            }
            
            // Set activeSerialInput to null to avoid any issues
            activeSerialInput = null;

            // Add diluent volume calculation event listeners
            document.getElementById('serial-final-volume').addEventListener('input', updateMaxDiluentVolume);
            document.getElementById('serial-diluent-percent').addEventListener('input', updateMaxDiluentVolume);
            
            // Initialize the diluent volume display
            updateMaxDiluentVolume();
    
            
            // Display the modal
            document.getElementById('serial-dilution-modal').style.display = 'block';
        }
    
        // Process serial dilution
        // Process serial dilution with repeating transfer volume pattern
        function processSerialDilution() {
            saveStateForUndo('serial-dilution', { sourceWells: selectedSourceWells, destWells: selectedDestinationWells });

            // Parse inputs with validation and ensure values are numbers
            const sourceConc = Number(document.getElementById('serial-source-concentration').value);
            const sourceUnit = document.getElementById('serial-source-unit').value;
            const topConc = Number(document.getElementById('serial-top-concentration').value);
            const topUnit = document.getElementById('serial-top-unit').value;
            const dilutionFold = Number(document.getElementById('serial-dilution-fold').value);
            const replicates = Number(document.getElementById('serial-replicates').value);
            const finalVolume = Number(document.getElementById('serial-final-volume').value);
            const direction = document.querySelector('input[name="direction"]:checked').value;
            
            // Get diluent information
            const diluentType = document.getElementById('serial-diluent-type').value;
            const diluentPercent = Number(document.getElementById('serial-diluent-percent').value);
            
            // Get the source wells
            const sourceWellsRange = document.getElementById('serial-source-wells').value;
            const sourceWells = parseWellRange(sourceWellsRange);
            const currentSourcePlate = plates.source.active;
            
            // NEW CODE: Check if any selected source wells are already diluted sources
            const existingDilutedSources = sourceWells.map(well => {
                const dilutedMapping = mappings.find(m => 
                    (m.type === "DILUTED_SOURCE" || m.isDilutedSource) && 
                    m.destinationPlate === currentSourcePlate && 
                    m.destination === well
                );
                return dilutedMapping ? {
                    well,
                    concentration: dilutedMapping.dilutedConcentration,
                    unit: dilutedMapping.sourceUnit,
                    dilutedConcInMicroMolar: dilutedMapping.dilutedConcInMicroMolar || 
                        convertToMicroMolar(dilutedMapping.dilutedConcentration, dilutedMapping.sourceUnit),
                    compoundID: dilutedMapping.compoundID,
                    originalCompoundID: dilutedMapping.originalCompoundID || dilutedMapping.compoundID.replace(' (Diluted)', '')
                } : null;
            }).filter(source => source !== null);
            
            const usingDilutedSource = existingDilutedSources.length > 0;
            
            // Basic validation
            if (!sourceConc && !usingDilutedSource) {
                alert('Please fill in source concentration or select a diluted source well');
                return;
            }
            
            if (!topConc || !dilutionFold || !finalVolume) {
                alert('Please fill in all concentration, dilution factor, and volume fields');
                return;
            }
            
            if (dilutionFold <= 1) {
                alert('Dilution factor must be greater than 1');
                return;
            }
            
            if (diluentPercent <= 0 || diluentPercent > 100) {
                alert('Diluent percentage must be between 0.1 and 100');
                return;
            }
            
            // Calculate maximum transfer volume based on diluent limit
            const maxTransferVolumeUL = (diluentPercent / 100) * finalVolume;
            const maxTransferVolumeNL = roundToEchoIncrement(maxTransferVolumeUL * 1000);
            
            console.log(`Diluent limit: ${diluentPercent}% of ${finalVolume}µL = ${maxTransferVolumeUL}µL = ${maxTransferVolumeNL}nL`);
            
            // Save current compound ID
            const currentCompoundID = compoundID;
            
            // If using a diluted source, adjust compound ID and concentration
            if (usingDilutedSource) {
                const dilutedSource = existingDilutedSources[0];
                console.log(`Using diluted source well ${dilutedSource.well} at ${dilutedSource.concentration} ${dilutedSource.unit}`);
                
                // Use the original compound ID if available
                if (dilutedSource.originalCompoundID) {
                    compoundID = dilutedSource.originalCompoundID;
                }
                
                // Override source concentration with the diluted source concentration
                document.getElementById('serial-source-concentration').value = dilutedSource.concentration;
                document.getElementById('serial-source-unit').value = dilutedSource.unit;
            }

            // Check if compound settings have a unit and use it
            if (window.compoundSettings[compoundID] && window.compoundSettings[compoundID].concentrationUnit) {
                document.getElementById('serial-source-unit').value = window.compoundSettings[compoundID].concentrationUnit;
            }

            // Update source well mappings with concentration information
            if (sourceConc && sourceUnit) {
                // Get source wells from the input
                const sourceWellsRange = document.getElementById('serial-source-wells').value;
                const sourceWells = parseWellRange(sourceWellsRange);
                const currentSourcePlate = plates.source.active;
                
                // Find existing mappings for these source wells
                const existingSourceMappings = mappings.filter(m => 
                    !m.type && !m.isDilutedSource && 
                    m.sourcePlate === currentSourcePlate &&
                    sourceWells.some(well => parseWellRange(m.source).includes(well))
                );
                
                // If no existing mapping, create one
                if (existingSourceMappings.length === 0 && sourceWells.length > 0) {
                    // Create a new mapping for the source wells
                    mappings.push({
                        sourcePlate: currentSourcePlate,
                        source: sourceWellsRange,
                        compoundID: compoundID,
                        color: getNextColor(),
                        concentration: sourceConc,  // Store concentration
                        concentrationUnit: sourceUnit  // Store unit
                    });
                } else {
                    // Update existing mappings
                    existingSourceMappings.forEach(mapping => {
                        mapping.concentration = sourceConc;
                        mapping.concentrationUnit = sourceUnit;
                    });
                }
            }

            // Convert source concentration to µM for calculations
            let sourceConcInMicroMolar;
            if (usingDilutedSource) {
                // Use the concentration from the diluted source
                sourceConcInMicroMolar = existingDilutedSources[0].dilutedConcInMicroMolar;
                console.log(`Using diluted source concentration: ${sourceConcInMicroMolar} µM`);
            } else {
                // Calculate from input values
                switch(sourceUnit) {
                    case 'mM': sourceConcInMicroMolar = sourceConc * 1000; break;
                    case 'nM': sourceConcInMicroMolar = sourceConc / 1000; break;
                    default: sourceConcInMicroMolar = sourceConc; // Already in µM
                }
            }
            
            // Convert top concentration to µM
            let topConcInMicroMolar;
            switch(topUnit) {
                case 'mM': topConcInMicroMolar = topConc * 1000; break;
                case 'nM': topConcInMicroMolar = topConc / 1000; break;
                default: topConcInMicroMolar = topConc; // Already in µM
            }
            
            console.log(`Source concentration: ${sourceConc} ${sourceUnit} = ${sourceConcInMicroMolar} µM`);
            console.log(`Top concentration: ${topConc} ${topUnit} = ${topConcInMicroMolar} µM`);
            
            // Make sure source is higher concentration than top dilution point
            if (sourceConcInMicroMolar <= topConcInMicroMolar) {
                alert('Error: Source concentration must be higher than top dilution concentration');
                return;
            }
            
            const destinationWells = selectedDestinationWells.map(well => well.split('_')[1]);
            const sortedWells = sortWellsByDirection(destinationWells, direction, replicates);

            const wellsToProcess = new Set(destinationWells);
            console.log(`Serial dilution targeting ${wellsToProcess.size} wells, preserving existing mappings`);

            // Optional: Count existing mappings for these wells
            const existingMappingCount = mappings.filter(m => 
                m.destinationPlate === plates.destination.active && 
                wellsToProcess.has(m.destination) &&
                (m.type === "DESTINATION" || (!m.type && !m.isDilutedSource))
            ).length;

            if (existingMappingCount > 0) {
                console.log(`Found ${existingMappingCount} existing compound mappings that will be preserved`);
            }
            
            // Group wells into concentration points
            let concentrationPoints = [];
            for (let i = 0; i < sortedWells.length; i += replicates) {
                const group = sortedWells.slice(i, i + replicates);
                if (group.length > 0) { // Handle incomplete groups
                    concentrationPoints.push(group);
                }
            }

            console.log(`Created ${concentrationPoints.length} concentration points with ${replicates} replicates each`);

            // Create dilution series
            globalDilutionSeries = [];
            let processedWells = new Set();

            // Generate a base color for this dilution series
            const baseColor = getCompoundColor(compoundID);

            // ----- START NEW PATTERN-BASED APPROACH -----
            
            // Identify the transfer volume pattern from original source well
            let currentConc = topConcInMicroMolar;
            const transferVolumePattern = [];
            let minValidTransferVolumeNL = 10; // Minimum valid transfer volume
            
            // Determine the pattern by calculating the first few points until we go below minimum
            let patternIndex = 0;
            let patternComplete = false;
            
            while (!patternComplete && patternIndex < concentrationPoints.length) {
                // Calculate transfer volume
                const transferVolumeUL = (currentConc * finalVolume) / sourceConcInMicroMolar;
                const transferVolumeNL = roundToEchoIncrement(transferVolumeUL * 1000);
                
                // If below minimum valid volume, we've found our pattern
                if (transferVolumeNL < minValidTransferVolumeNL) {
                    patternComplete = true;
                } else {
                    // Add to pattern
                    transferVolumePattern.push(transferVolumeNL);
                    patternIndex++;
                    currentConc /= dilutionFold; // Move to next concentration
                }
            }
            
            console.log(`Identified transfer volume pattern: ${transferVolumePattern.join(', ')} nL`);
            
            // If we couldn't establish a pattern (all points are below minimum)
            if (transferVolumePattern.length === 0) {
                alert('Cannot establish a valid transfer volume pattern. Please check your concentrations.');
                return;
            }
            
            // Reset for actual processing
            currentConc = topConcInMicroMolar;
            
            // Create structures to collect dilution data
            let allWellsNeedingDilution = [];
            let dilutedSourceBatches = [];
            let patternSize = transferVolumePattern.length;
            
            // Process each concentration point with the pattern
            concentrationPoints.forEach((wellGroup, pointIndex) => {
                // Calculate which batch this belongs to (original source is batch 0)
                const batchNumber = Math.floor(pointIndex / patternSize);
                const patternPosition = pointIndex % patternSize;
                
                console.log(`Point ${pointIndex+1}: Concentration = ${currentConc.toFixed(4)} µM (Batch ${batchNumber}, Position ${patternPosition})`);
                
                // Get the transfer volume based on pattern position
                const transferVolumeNL = transferVolumePattern[patternPosition];
                
                // Calculate color opacity based on concentration index
                const totalPoints = concentrationPoints.length;
                const opacity = 1 - (pointIndex / (totalPoints * 1.2));
                const pointColor = createColorWithOpacity(baseColor, opacity);
                
                // If this is the original source batch
                if (batchNumber === 0) {
                    // Calculate if transfer volume exceeds diluent limit
                    const transferVolumeUL = transferVolumeNL / 1000;
                    let diluentLimitExceeded = transferVolumeUL > maxTransferVolumeUL;
                    let actualTransferVolumeNL = diluentLimitExceeded ? maxTransferVolumeNL : transferVolumeNL;
                    
                    // Calculate actual concentration if needed
                    let actualConcentration = currentConc;
                    if (diluentLimitExceeded) {
                        actualConcentration = (actualTransferVolumeNL / 1000) * sourceConcInMicroMolar / finalVolume;
                        console.log(`  Diluent limit exceeded. Actual concentration will be ${actualConcentration.toFixed(4)} µM`);
                    }
                    
                    // Create mapping for each well in the group
                    wellGroup.forEach(well => {
                        if (!processedWells.has(well)) {
                            // Create mapping with diluent information
                            mappings.push({
                                sourcePlate: plates.source.active,
                                destinationPlate: plates.destination.active,
                                source: document.getElementById('serial-source-wells').value,
                                destination: well,
                                transferVolume: actualTransferVolumeNL.toFixed(2),
                                compoundID: compoundID,
                                color: pointColor,
                                sourceConcentration: sourceConc,
                                sourceUnit: sourceUnit,
                                destinationConcentration: diluentLimitExceeded ? 
                                    convertFromMicroMolar(actualConcentration, topUnit) : 
                                    convertFromMicroMolar(currentConc, topUnit),
                                destinationUnit: topUnit,
                                finalVolume: finalVolume,
                                expectedConcentration: currentConc.toFixed(4), // Target concentration
                                actualConcentration: diluentLimitExceeded ? actualConcentration.toFixed(4) : currentConc.toFixed(4), // Actual concentration
                                diluentType: diluentType,
                                diluentPercent: (transferVolumeUL / finalVolume * 100).toFixed(2), // Actual percentage
                                diluentLimitExceeded: diluentLimitExceeded
                            });
                            processedWells.add(well);
                            console.log(`  Created mapping for well ${well}: ${actualTransferVolumeNL.toFixed(2)} nL`);
                        }
                    });
                } else {
                    // This needs to come from a diluted source
                    // Aggregate the wells needing this diluted source batch
                    wellGroup.forEach(well => {
                        // Track wells for this batch
                        if (!dilutedSourceBatches[batchNumber-1]) {
                            dilutedSourceBatches[batchNumber-1] = [];
                        }
                        
                        dilutedSourceBatches[batchNumber-1].push({
                            destination: well,
                            transferVolume: transferVolumeNL,
                            expectedConcentration: currentConc,
                            patternPosition: patternPosition,
                            batchNumber: batchNumber,
                            destinationConcentration: convertFromMicroMolar(currentConc, topUnit),
                            destinationUnit: topUnit,
                            sourceConcentration: sourceConc,
                            sourceUnit: sourceUnit,
                            finalVolume: finalVolume,
                            colorString: pointColor,
                            diluentType: diluentType,
                            diluentPercent: diluentPercent
                        });
                        
                        // Also add to the flat list for backward compatibility
                        allWellsNeedingDilution.push({
                            destination: well,
                            transferVolume: transferVolumeNL,
                            expectedConcentration: currentConc,
                            destinationConcentration: convertFromMicroMolar(currentConc, topUnit),
                            destinationUnit: topUnit,
                            sourceConcentration: sourceConc,
                            sourceUnit: sourceUnit,
                            finalVolume: finalVolume,
                            colorString: pointColor,
                            diluentType: diluentType,
                            diluentPercent: diluentPercent
                        });
                    });
                }
                
                // Continue to next concentration
                currentConc /= dilutionFold;
            });
            
            // Process diluted source batches if needed
            if (dilutedSourceBatches.length > 0) {
                // Calculate dilution factors for each batch
                let dilutedSourceInfo = [];
                
                dilutedSourceBatches.forEach((batch, batchIndex) => {
                    // The dilution factor needs to be dilutionFold^patternSize for each batch
                    const dilutionFactor = Math.pow(dilutionFold, patternSize);
                    
                    // Calculate the diluted concentration for this batch
                    // For batch 1, it's source / dilutionFactor
                    // For batch 2, it's source / (dilutionFactor^2), etc.
                    const cumulativeDilutionFactor = Math.pow(dilutionFactor, batchIndex + 1);
                    const dilutedSourceConcInMicroMolar = sourceConcInMicroMolar / cumulativeDilutionFactor;
                    
                    console.log(`Batch ${batchIndex+1} requires source diluted by factor of ${cumulativeDilutionFactor}x`);
                    console.log(`  Original: ${sourceConcInMicroMolar} µM → Diluted: ${dilutedSourceConcInMicroMolar} µM`);
                    
                    // Record the diluted source information
                    dilutedSourceInfo.push({
                        originalUnit: sourceUnit,
                        originalConc: sourceConc,
                        originalConcInMicroMolar: sourceConcInMicroMolar,
                        dilutionFactor: cumulativeDilutionFactor,
                        dilutedConcInMicroMolar: dilutedSourceConcInMicroMolar,
                        points: batch,
                        concentrationRange: [
                            Math.max(...batch.map(p => p.expectedConcentration)),
                            Math.min(...batch.map(p => p.expectedConcentration))
                        ],
                        patternPositions: [...new Set(batch.map(p => p.patternPosition))].sort()
                    });
                });
                
                console.log("Diluted source information:", dilutedSourceInfo);
                
                // Prepare for dilution split modal
                window.dilutionSplitData = {
                    wellsNeedingDilution: allWellsNeedingDilution,
                    sourceConc, // Original source concentration value
                    sourceUnit, // Original source unit
                    sourceConcInMicroMolar, // Converted to microMolar
                    dilutedSources: dilutedSourceInfo,
                    availableSourceWells: findAvailableSourceWells(),
                    finalVolume,
                    diluentType: diluentType,
                    diluentPercent: diluentPercent,
                    transferVolumePattern: transferVolumePattern // Store the pattern for reference
                };
                
                // Show dilution split modal
                showDilutionSplitModal(allWellsNeedingDilution, sourceConcInMicroMolar, finalVolume, diluentType, diluentPercent);
                return; // Exit as we'll continue processing after modal
            }

            // Hide modal
            document.getElementById('serial-dilution-modal').style.display = 'none';
            
            // Clear selections
            selectedSourceWells = [];
            selectedDestinationWells = [];
            document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
            
            // Restore compound ID
            compoundID = currentCompoundID;
            
            // Refresh displays
            refreshPlateDisplay('source');
            refreshPlateDisplay('destination');
            
            // Update buttons
            updateMapButton();
            updateSaveButton();
            
            console.log("Serial dilution completed successfully");
        }


        // Modified function for handling dilution split
        function showDilutionSplitModal(wellsNeedingDilution, sourceConcInMicroMolar, finalVolume, diluentType, diluentPercent) {
            const splitModal = document.getElementById('dilution-split-modal');
            const splitTable = document.getElementById('dilution-split-preview');
            
            // Clear existing rows
            splitTable.innerHTML = '';
            
            // Get source information from the inputs
            const sourceConc = parseFloat(document.getElementById('serial-source-concentration').value);
            const sourceUnit = document.getElementById('serial-source-unit').value;
            
            console.log("Source concentration:", sourceConc, sourceUnit);
            console.log("Source in µM:", sourceConcInMicroMolar);
            
            // Get diluted sources from the data we prepared
            const dilutedSources = window.dilutionSplitData.dilutedSources;
            const transferVolumePattern = window.dilutionSplitData.transferVolumePattern;
            
            console.log("Transfer volume pattern:", transferVolumePattern);
            console.log("Processing diluted sources:", dilutedSources);
            
            // Get available source wells that aren't already used
            const existingSourceWells = mappings
                .filter(m => m.type === "DILUTED_SOURCE" || m.isDilutedSource)
                .map(m => m.destination);
            
            // Call the updated function to get available wells (excluding backfiller wells)
            const availableSourceWells = findAvailableSourceWells().filter(well => 
                !existingSourceWells.includes(well)
            );
            
            console.log("Available source wells:", availableSourceWells);
            
            // Generate table rows for each diluted source
            dilutedSources.forEach((source, idx) => {
                // Check for existing diluted sources with matching concentration
                const concentrationTolerancePercent = 1; // 1% tolerance
                const existingDilutedSource = mappings.find(m => 
                    (m.type === "DILUTED_SOURCE" || m.isDilutedSource) &&
                    m.destinationPlate === plates.source.active &&
                    Math.abs(
                        (m.dilutedConcInMicroMolar - source.dilutedConcInMicroMolar) / source.dilutedConcInMicroMolar * 100
                    ) < concentrationTolerancePercent
                );
                
                // NEW CODE: Check if compound also matches
                let isMatchingSource = false;
                if (existingDilutedSource) {
                    const currentCompoundID = compoundID;
                    const existingCompoundID = existingDilutedSource.originalCompoundID || 
                        existingDilutedSource.compoundID.replace(/ \([^)]+\)$/, '');
                    
                    // Only consider it a match if BOTH concentration and compound match
                    isMatchingSource = (existingCompoundID === currentCompoundID);
                    console.log(`Checking compound match for well ${existingDilutedSource.destination}: ${existingCompoundID} vs ${currentCompoundID} = ${isMatchingSource}`);
                }
                
                // Get the next available source well or use existing matching diluted source
                let wellName;
                if (existingDilutedSource && isMatchingSource) {
                    wellName = existingDilutedSource.destination;
                    console.log(`Found existing diluted source in well ${wellName} with matching concentration and compound`);
                } else {
                    wellName = availableSourceWells[idx] || `[Select Well]`;
                }
                
                // Convert from microMolar to appropriate display unit
                let displayConc;
                let displayUnit;
                
                // For clarity, always show the diluted concentration in a unit that gives a reasonable number
                // This is just for display - calculations still use microMolar
                const concInMicroMolar = source.dilutedConcInMicroMolar;
                
                if (concInMicroMolar >= 1000) {
                    // Show as mM if >= 1000 µM
                    displayConc = (concInMicroMolar / 1000).toFixed(2);
                    displayUnit = 'mM';
                } else if (concInMicroMolar >= 1) {
                    // Show as µM if >= 1 µM
                    displayConc = concInMicroMolar.toFixed(2);
                    displayUnit = 'µM';
                } else {
                    // Show as nM if < 1 µM
                    displayConc = (concInMicroMolar * 1000).toFixed(2);
                    displayUnit = 'nM';
                }
                
                console.log(`Diluted source ${idx+1} display: ${displayConc} ${displayUnit} (${concInMicroMolar} µM)`);
                
                // Format concentration range
                const minConc = source.concentrationRange[1].toFixed(2);
                const maxConc = source.concentrationRange[0].toFixed(2);
                const rangeText = minConc === maxConc ? 
                                `${minConc} µM` : 
                                `${maxConc} - ${minConc} µM`;
                
                // Create row with input field for well selection - only readonly if BOTH concentration and compound match
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>Source ${idx + 1}</td>
                    <td>
                        <input type="text" 
                            id="new-source-well-${idx}" 
                            value="${wellName}"
                            class="new-source-well-input"
                            data-source-index="${idx}"
                            ${(existingDilutedSource && isMatchingSource) ? 'readonly style="background-color:#f0f0f0;"' : ''}>
                        ${(existingDilutedSource && isMatchingSource) ? '<span style="font-size:10px; color:green;">(Existing)</span>' : ''}
                        ${(existingDilutedSource && !isMatchingSource) ? '<span style="font-size:10px; color:orange;">(Different compound)</span>' : ''}
                    </td>
                    <td>${displayConc} ${displayUnit}</td>
                    <td>${source.dilutionFactor}x</td>
                    <td>${rangeText}</td>
                `;
                splitTable.appendChild(row);
                
                // Store reference to existing source if found AND matching
                if (existingDilutedSource && isMatchingSource) {
                    source.existingSource = existingDilutedSource;
                }
            });
            
            // Show modal
            splitModal.style.display = 'block';
        }
    
        // Helper function to convert microMolar concentration from any unit
        function convertToMicroMolar(concentration, unit) {
            switch(unit) {
                case 'mM': return concentration * 1000;
                case 'nM': return concentration / 1000;
                default: return concentration; // Already in µM
            }
        }
    
        // Helper function to convert from microMolar to the desired unit
        function convertFromMicroMolar(concentration, unit) {
            switch(unit) {
                case 'mM': return concentration / 1000;
                case 'nM': return concentration * 1000;
                default: return concentration; // Keep as µM
            }
        }
    
    
        // Modified function to handle the split dilution confirmation
        function handleSplitDilution(sourceWells) {
            saveStateForUndo('split-dilution', { data: window.dilutionSplitData });
            // Get dilution data
            const data = window.dilutionSplitData;
            // Get diluent information
            const diluentType = data.diluentType || 'DMSO';
            const diluentPercent = data.diluentPercent || 2.0;
            
            if (!data || !data.dilutedSources) {
                console.error("Missing dilution data");
                return;
            }

            // IMPORTANT: Save all backfiller mappings first
            const backfillerMappings = mappings.filter(m => m.type === "BACKFILL_SOURCE");
            console.log(`Saving ${backfillerMappings.length} backfiller mappings before split dilution`);
            
            // Original source information
            const originalSourceConc = data.sourceConc;
            const originalSourceUnit = data.sourceUnit;
            const sourceConcInMicroMolar = data.sourceConcInMicroMolar;
            const finalVolume = data.finalVolume; 
            const transferVolumePattern = data.transferVolumePattern;
            
            console.log("Original source:", originalSourceConc, originalSourceUnit, "=", sourceConcInMicroMolar, "µM");
            console.log("Final volume:", finalVolume, "µL");
            console.log("Transfer volume pattern:", transferVolumePattern);
            
            // Save current compound ID since this process may modify it temporarily
            const currentCompoundID = compoundID;
            
            // Create diluted source wells
            data.dilutedSources.forEach((dilutedSource, idx) => {
                const sourceWell = sourceWells[idx];
                if (!sourceWell) {
                    console.error(`Missing source well for diluted source ${idx}`);
                    return;
                }
                
                // NEW CODE: Check if this is already a matching diluted source - skip creation if so
                if (dilutedSource.existingSource) {
                    console.log(`Reusing existing diluted source in well ${sourceWell} with concentration ${dilutedSource.dilutedConcInMicroMolar.toFixed(4)} µM`);
                    // No need to create a new mapping as we're reusing the existing one
                } else {
                    // Calculate the diluted concentration
                    const dilutedConcInMicroMolar = dilutedSource.dilutedConcInMicroMolar;
                    
                    console.log(`Creating new diluted source ${idx+1} in well ${sourceWell}: ${dilutedConcInMicroMolar.toFixed(4)} µM (Dilution factor: ${dilutedSource.dilutionFactor}x)`);
                    
                    // Convert to appropriate display unit
                    let displayConc;
                    let displayUnit;
                    
                    if (dilutedConcInMicroMolar >= 1000) {
                        // Show as mM if >= 1000 µM
                        displayConc = (dilutedConcInMicroMolar / 1000).toFixed(2);
                        displayUnit = 'mM';
                    } else if (dilutedConcInMicroMolar >= 1) {
                        // Show as µM if >= 1 µM
                        displayConc = dilutedConcInMicroMolar.toFixed(2);
                        displayUnit = 'µM';
                    } else {
                        // Show as nM if < 1 µM
                        displayConc = (dilutedConcInMicroMolar * 1000).toFixed(2);
                        displayUnit = 'nM';
                    }
                    
                    // Find color to use (from dilution points or generate one)
                    let dilutedSourceColor = getCompoundColor(compoundID);
                    
                    // Try to use color from the first point this source will handle
                    if (dilutedSource.points.length > 0 && dilutedSource.points[0].colorString) {
                        dilutedSourceColor = dilutedSource.points[0].colorString;
                    }
                    
                    // Create diluted source well mapping
                    mappings.push({
                        type: "DILUTED_SOURCE",
                        isDilutedSource: true,
                        sourcePlate: plates.source.active,
                        destinationPlate: plates.source.active, // In source plate
                        source: document.getElementById('serial-source-wells').value, // Original source
                        destination: sourceWell,
                        transferVolume: "0", // No actual transfer for this marker
                        compoundID: `${compoundID} (${displayConc} ${displayUnit})`,
                        color: dilutedSourceColor,
                        dilutedConcentration: parseFloat(displayConc), // Numeric value
                        sourceUnit: displayUnit, // Display unit
                        originalConcentration: originalSourceConc,
                        originalUnit: originalSourceUnit,
                        dilutionFactor: dilutedSource.dilutionFactor,
                        originalCompoundID: compoundID,
                        dilutedConcInMicroMolar: dilutedConcInMicroMolar, // Store the µM value for calculations
                        locationIdentifier: `SOURCE_PLATE_${plates.source.active}_WELL_${sourceWell}`,
                        patternPositions: dilutedSource.patternPositions // Store which positions in the pattern this handles
                    });
                    
                    console.log(`Created diluted source well: ${sourceWell} (${displayConc} ${displayUnit})`);
                }
                
                // Create destination mappings for each point handled by this diluted source
                dilutedSource.points.forEach(point => {
                    // Define these variables first to ensure they're always available
                    let displayConc;
                    let displayUnit;
                    
                    // Calculate display values for concentration if using a new source
                    if (!dilutedSource.existingSource) {
                        const dilutedConcInMicroMolar = dilutedSource.dilutedConcInMicroMolar;
                        
                        if (dilutedConcInMicroMolar >= 1000) {
                            // Show as mM if >= 1000 µM
                            displayConc = (dilutedConcInMicroMolar / 1000).toFixed(2);
                            displayUnit = 'mM';
                        } else if (dilutedConcInMicroMolar >= 1) {
                            // Show as µM if >= 1 µM
                            displayConc = dilutedConcInMicroMolar.toFixed(2);
                            displayUnit = 'µM';
                        } else {
                            // Show as nM if < 1 µM
                            displayConc = (dilutedConcInMicroMolar * 1000).toFixed(2);
                            displayUnit = 'nM';
                        }
                    } else {
                        // Get values from existing source
                        displayConc = dilutedSource.existingSource.dilutedConcentration;
                        displayUnit = dilutedSource.existingSource.sourceUnit;
                    }
                    
                    // Get correct source well mapping - either the existing one or the newly created one
                    const sourceWellMapping = dilutedSource.existingSource || {
                        destination: sourceWell,
                        dilutedConcInMicroMolar: dilutedSource.dilutedConcInMicroMolar,
                        dilutedConcentration: parseFloat(displayConc),
                        sourceUnit: displayUnit
                    };
                    
                    // Get finalVolume - first check point, then data, then default to 100
                    const pointFinalVolume = point.finalVolume || finalVolume || 100;
                    
                    // Calculate maximum allowed transfer volume based on diluent limit
                    const maxDiluentVolumeUL = (diluentPercent / 100) * pointFinalVolume;
                    const maxDiluentVolumeNL = roundToEchoIncrement(maxDiluentVolumeUL * 1000);
                    
                    // Use the transfer volume from the pattern position
                    const patternPosition = point.patternPosition;
                    let transferVolumeNL = transferVolumePattern[patternPosition];
                    const transferVolumeUL = transferVolumeNL / 1000;
                    
                    // Check if transfer volume exceeds diluent limit
                    let diluentLimitExceeded = false;
                    
                    if (transferVolumeUL > maxDiluentVolumeUL) {
                        console.log(`  WARNING: Diluted source transfer volume ${transferVolumeUL.toFixed(4)} µL exceeds diluent limit ${maxDiluentVolumeUL.toFixed(4)} µL`);
                        // Set to the maximum permitted by diluent limit and flag for notification
                        transferVolumeNL = maxDiluentVolumeNL;
                        diluentLimitExceeded = true;
                    }
                    
                    // Calculate actual concentration when limited by diluent
                    let actualConcentration = point.expectedConcentration;
                    if (diluentLimitExceeded) {
                        actualConcentration = (transferVolumeNL / 1000) * sourceWellMapping.dilutedConcInMicroMolar / pointFinalVolume;
                        console.log(`  Diluent limit exceeded. Actual concentration will be ${actualConcentration.toFixed(4)} µM`);
                    }
                    
                    // Create explicit destination mapping
                    mappings.push({
                        type: "DESTINATION",
                        sourcePlate: plates.source.active,
                        destinationPlate: plates.destination.active,
                        source: `{${sourceWellMapping.destination}}`, // Source is the diluted source well
                        destination: point.destination,
                        transferVolume: transferVolumeNL.toFixed(2),
                        compoundID: compoundID,
                        color: point.colorString || dilutedSourceColor,
                        expectedConcentration: point.expectedConcentration.toFixed(4),
                        destinationConcentration: point.destinationConcentration,
                        destinationUnit: point.destinationUnit,
                        sourceConcentration: sourceWellMapping.dilutedConcentration,
                        sourceUnit: sourceWellMapping.sourceUnit,
                        sourceConcInMicroMolar: sourceWellMapping.dilutedConcInMicroMolar, // Store µM concentration for calculations
                        finalVolume: pointFinalVolume,
                        actualConcentration: diluentLimitExceeded ? actualConcentration.toFixed(4) : point.expectedConcentration.toFixed(4),
                        diluentType: diluentType,
                        diluentPercent: ((transferVolumeNL / 1000) / pointFinalVolume * 100).toFixed(2), // Calculate actual percentage
                        diluentLimitExceeded: diluentLimitExceeded
                    });
                    
                    console.log(`Created mapping for destination well ${point.destination}: ${transferVolumeNL.toFixed(2)} nL from diluted source ${sourceWellMapping.destination}`);
                });
            });
            
            // Hide serial dilution modal - IMPORTANT: we close both modals
            document.getElementById('dilution-split-modal').style.display = 'none';
            document.getElementById('serial-dilution-modal').style.display = 'none';
            
            // Clear selections
            selectedSourceWells = [];
            selectedDestinationWells = [];
            document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
            
            // Restore compound ID
            compoundID = currentCompoundID;

            // Make sure we haven't lost any backfiller mappings
            const currentBackfillerMappings = mappings.filter(m => m.type === "BACKFILL_SOURCE");
            if (currentBackfillerMappings.length < backfillerMappings.length) {
                console.warn("Restoring lost backfiller mappings...");
                
                // Add any missing backfiller mappings back
                backfillerMappings.forEach(mapping => {
                    // Check if this mapping is missing
                    const stillExists = mappings.some(m => 
                        m.type === "BACKFILL_SOURCE" && 
                        m.destination === mapping.destination &&
                        m.sourcePlate === mapping.sourcePlate &&
                        m.destinationPlate === mapping.destinationPlate
                    );
                    
                    // If missing, add it back
                    if (!stillExists) {
                        console.log(`Restoring backfiller mapping for well ${mapping.destination}`);
                        mappings.push(mapping);
                    }
                });
            }
            
            // Refresh displays
            refreshPlateDisplay('source');
            refreshPlateDisplay('destination');
            
            // Update UI state
            updateMapButton();
            updateSaveButton();
            
            console.log("Split dilution completed successfully");
        }
    
        // ----- IMPORT/EXPORT FUNCTIONS -----
        
        // Export template for CSV import
        function exportCSVTemplate() {
            const header = 'Well,Compound_ID,Concentration,Unit\n';
            let content = header;
            
            // Add some example rows
            content += 'A1,COMPOUND-001,10,mM\n';
            content += 'A2,COMPOUND-001,10,mM\n';
            content += 'B1,COMPOUND-002,5,mM\n';
            content += 'B2,COMPOUND-002,5,mM\n';
            
            const blob = new Blob([content], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'cherrypick_template.csv';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }
    
        // Process and import CSV
        async function readAndProcessCSV(file) {
            saveStateForUndo('import-csv', { oldMappings: [...mappings] });
            try {
                const text = await file.text();
                const lines = text.split('\n');
                
                if (lines.length <= 1) {
                    alert('CSV file appears to be empty or has only headers');
                    return;
                }
                
                console.log("First few lines of CSV:");
                console.log(lines.slice(0, 3));
                
                // Detect separator (comma, semicolon, or tab)
                const firstLine = lines[0];
                const separator = firstLine.includes(',') ? ',' : 
                                firstLine.includes(';') ? ';' : '\t';
                
                // Parse headers and convert to lowercase for case-insensitive matching
                const headers = lines[0].split(separator).map(h => h.trim().toLowerCase());
                console.log("Headers found:", headers);
                
                // Find required columns - be very flexible with column names
                const wellColIndex = findColumnIndex(headers, ['well', 'position', 'loc', 'location']);
                const compoundColIndex = findColumnIndex(headers, ['compound', 'id', 'compound_id', 'compoundid', 'compound id']);
                const concIndex = findColumnIndex(headers, ['conc', 'concentration', 'concentration_mm', 'concentration_um']);
                
                // Validate columns
                if (wellColIndex === -1) {
                    alert('Could not find well position column. Please ensure your CSV has a column named Well, Position, etc.');
                    return;
                }
                
                if (compoundColIndex === -1) {
                    alert('Could not find compound ID column. Please ensure your CSV has a column named ID, Compound ID, etc.');
                    return;
                }
                
                console.log("Column indices found:", {well: wellColIndex, compound: compoundColIndex, concentration: concIndex});
                
                // Clear existing data if checked
                const clearBeforeImport = document.getElementById('clear-before-import')?.checked ?? true;
                if (clearBeforeImport) {
                    const currentSourcePlate = plates.source.active;
                    console.log(`Clearing existing data for source plate ${currentSourcePlate}`);
                    
                    mappings = mappings.filter(m => m.sourcePlate !== currentSourcePlate);
                    
                    Object.keys(window.sourceWellDataStore).forEach(key => {
                        if (key.startsWith(`${currentSourcePlate}-`)) {
                            delete window.sourceWellDataStore[key];
                        }
                    });
                }
                
                // Current plate information
                const currentSourcePlate = plates.source.active;
                console.log(`Importing to source plate: ${currentSourcePlate}`);
                
                // Track import stats
                let importCount = 0;
                let importedCompounds = new Set();
                let wellsToColor = [];
                
                // Track wells by compound for coloring
                const wellsByCompound = {};
                
                // Process data rows - use a more direct approach
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    const cells = line.split(separator).map(v => v.trim());
                    if (cells.length <= Math.max(wellColIndex, compoundColIndex)) continue;
                    
                    // Get well and compound
                    let well = cells[wellColIndex].toUpperCase().trim();
                    const compound = cells[compoundColIndex].trim();
                    
                    // Skip if missing data
                    if (!well || !compound) {
                        console.log(`Line ${i+1}: Missing well or compound - Well: ${well}, Compound: ${compound}`);
                        continue;
                    }
                    
                    // Clean well format - ensure A1 format without spaces
                    well = well.replace(/\s+/g, '');
                    
                    console.log(`Processing line ${i+1}: Well ${well}, Compound ${compound}`);
                    
                    // Get concentration if available
                    let concentration = null;
                    let unit = 'mM'; // Default unit
                    
                    if (concIndex !== -1 && cells[concIndex]) {
                        concentration = parseFloat(cells[concIndex].replace(',', '.'));
                        // Detect unit from header if possible
                        const concHeader = headers[concIndex].toLowerCase();
                        if (concHeader.includes('_mm')) unit = 'mM';
                        else if (concHeader.includes('_um')) unit = 'µM';
                        else if (concHeader.includes('_nm')) unit = 'nM';
                    }
                    
                    // Store data in sourceWellDataStore
                    const wellKey = `${currentSourcePlate}-${well}`;
                    window.sourceWellDataStore[wellKey] = {
                        concentration: concentration,
                        unit: unit,
                        compoundID: compound
                    };
                    
                    console.log(`Stored data for ${wellKey}: ${compound} (${concentration} ${unit})`);
                    
                    // Track for coloring
                    if (!wellsByCompound[compound]) {
                        wellsByCompound[compound] = [];
                    }
                    wellsByCompound[compound].push(well);
                    
                    // Track import stats
                    importCount++;
                    importedCompounds.add(compound);
                    wellsToColor.push(well);
                }
                
                console.log(`CSV processing complete. Found ${importCount} wells for ${importedCompounds.size} compounds`);
                
                // Create color mappings for each compound
                Object.entries(wellsByCompound).forEach(([compound, wells]) => {
                    if (wells.length === 0) return;
                    
                    // Generate color
                    const color = getCompoundColor(compound);
                    console.log(`Assigning color ${color} to compound ${compound} with ${wells.length} wells`);
                    
                    // Get concentration if available from first well
                    let concentration = null;
                    let unit = 'mM';
                    
                    const firstWellKey = `${currentSourcePlate}-${wells[0]}`;
                    if (window.sourceWellDataStore[firstWellKey]) {
                        concentration = window.sourceWellDataStore[firstWellKey].concentration;
                        unit = window.sourceWellDataStore[firstWellKey].unit;
                    }
                    
                    // Create one mapping per compound
                    mappings.push({
                        sourcePlate: currentSourcePlate,
                        source: `{${wells.join(';')}}`,
                        compoundID: compound,
                        color: color,
                        concentration: concentration,
                        concentrationUnit: unit
                    });
                });
                
                // CRITICAL PART: First completely regenerate the plate
                console.log("Regenerating plate...");
                generatePlate('source-plate', parseInt(document.getElementById('source-plate-type-selector').value));
                
                // Allow time for DOM to update 
                setTimeout(() => {
                    // Now apply colors directly to well elements for guaranteed visualization
                    console.log("Directly applying colors to wells...");
                    Object.entries(wellsByCompound).forEach(([compound, wells]) => {
                        // Find the mapping to get the color
                        const mapping = mappings.find(m => 
                            m.compoundID === compound && 
                            m.sourcePlate === currentSourcePlate
                        );
                        
                        if (!mapping) {
                            console.warn(`No mapping found for compound ${compound}`);
                            return;
                        }
                        
                        // Apply color to each well
                        wells.forEach(wellId => {
                            const wellElement = document.getElementById(`source-plate_${wellId}`);
                            if (wellElement) {
                                wellElement.classList.add('mapped');
                                wellElement.style.backgroundColor = mapping.color;
                                console.log(`Applied color ${mapping.color} to well ${wellId}`);
                            } else {
                                console.warn(`Could not find element for well: source-plate_${wellId}`);
                                // Check what elements do exist
                                const allWells = document.querySelectorAll('.well');
                                console.log(`Found ${allWells.length} wells total`);
                                if (allWells.length < 10) {
                                    console.log("Well IDs:", Array.from(allWells).map(w => w.id));
                                }
                            }
                        });
                    });
                    
                    // Then call standard refresh
                    console.log("Calling standard refresh...");
                    refreshPlateDisplay('source');
                    
                    // Update UI
                    updatePlateTabs('source');
                    updateSaveButton();
                    updateWellAttributesTables();
                    
                    console.log("Import process completed");
                    alert(`Successfully imported ${importCount} wells for ${importedCompounds.size} compounds.`);
                }, 100);
                
            } catch (error) {
                console.error('Error processing CSV:', error);
                alert(`Error processing CSV file: ${error.message}`);
            }
        }

        // Helper function to find column index with multiple possible names
        function findColumnIndex(headers, possibleNames) {
            // Try exact matches first
            for (const name of possibleNames) {
                const index = headers.findIndex(h => h === name);
                if (index !== -1) return index;
            }
            
            // Try partial matches
            for (const name of possibleNames) {
                const index = headers.findIndex(h => h.includes(name));
                if (index !== -1) return index;
            }
            
            return -1;
        }
    
        // Convert mappings to CSV for export
        function convertToCSV(mappings) {
            // Filter down to mappings with destination (transfers)
            const transferMappings = mappings.filter(m => 
                m.destination && 
                m.sourcePlate && 
                m.destinationPlate && 
                parseFloat(m.transferVolume) >= 2.5
            );
            
            // Create header
            const header = 'Source Plate Name,Source Well,Destination Plate Name,Destination Well,Transfer Volume,Compound ID,Source Concentration,Source Unit,Destination Concentration,Destination Unit\n';
            
            // Create rows
            const rows = transferMappings.map(mapping => {
                // Ensure source well has curly braces for all types, especially backfill
                let sourceWellsStr = mapping.source || '';
                
                // Make sure sourceWellsStr has curly braces if it doesn't
                if (sourceWellsStr && !sourceWellsStr.startsWith('{')) {
                    sourceWellsStr = `{${sourceWellsStr}}`;
                }
                
                // Round concentration values to 4 decimal places to avoid long trailing decimals
                let sourceConc = mapping.sourceConcentration || '';
                let destConc = mapping.destinationConcentration || '';
                
                if (typeof sourceConc === 'number') {
                    sourceConc = parseFloat(sourceConc.toFixed(4));
                }
                
                if (typeof destConc === 'number') {
                    destConc = parseFloat(destConc.toFixed(4));
                }
                
                // Get plate names
                const sourcePlateName = plates.source.plates[mapping.sourcePlate] ? 
                    plates.source.plates[mapping.sourcePlate].name || `Plate ${mapping.sourcePlate}` : 
                    `Plate ${mapping.sourcePlate}`;
                    
                const destPlateName = plates.destination.plates[mapping.destinationPlate] ? 
                    plates.destination.plates[mapping.destinationPlate].name || `Plate ${mapping.destinationPlate}` : 
                    `Plate ${mapping.destinationPlate}`;
                
                // Basic fields - use plate names instead of just numbers
                const baseFields = [
                    sourcePlateName,
                    sourceWellsStr,
                    destPlateName,
                    mapping.destination,
                    parseFloat(mapping.transferVolume).toFixed(2),
                    mapping.compoundID
                ];
                
                // For backfill mappings, don't include concentration units
                if (mapping.type === "BACKFILL" || mapping.isBackfill) {
                    return [...baseFields, '', '', '', ''].join(',');
                }
                
                // Add concentration fields for regular mappings
                const sourceUnit = mapping.sourceUnit || '';
                const destUnit = mapping.destinationUnit || '';
                
                return [...baseFields, sourceConc, sourceUnit, destConc, destUnit].join(',');
            }).join('\n');
            
            return header + rows;
        }
    
        // Export mappings to file
        function exportMappings() {
            const format = document.getElementById('format-selector').value;
            let content, filename, type;
            
            if (format === 'csv') {
                content = convertToCSV(mappings);
                filename = 'mappings.csv';
                type = 'text/csv';
            } else {
                content = JSON.stringify(mappings, null, 2);
                filename = 'mappings.json';
                type = 'application/json';
            }
            
            const blob = new Blob([content], { type });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }
    
        // function to export source plate info
        function exportSourcePlateInfo() {
            // Get current source plate
            const currentSourcePlate = plates.source.active;
            const currentPlateName = plates.source.plates[currentSourcePlate] ? 
                plates.source.plates[currentSourcePlate].name : `Plate ${currentSourcePlate}`;
            
            // Create header
            const header = 'Plate,Well,Compound ID,Concentration,Unit,Type,Notes\n';
            
            // Gather all source well information
            const rows = [];
            
            // First get from the sourceWellDataStore
            Object.keys(window.sourceWellDataStore).forEach(key => {
                if (key.startsWith(`${currentSourcePlate}-`)) {
                    const [plateNum, wellId] = key.split('-');
                    const wellData = window.sourceWellDataStore[key];
                    
                    rows.push([
                        currentPlateName,
                        wellId,
                        wellData.compoundID || '',
                        wellData.concentration || '',
                        wellData.unit || '',
                        wellData.isDiluted ? 'Diluted Source' : 'Standard',
                        wellData.isDiluted ? `Diluted ${wellData.dilutionFactor}x` : ''
                    ]);
                }
            });
            
            // Then check mappings for additional information
            mappings.forEach(mapping => {
                // Check both sourcePlate and destinationPlate (diluted sources use destinationPlate)
                if (mapping.sourcePlate !== currentSourcePlate && mapping.destinationPlate !== currentSourcePlate) return;
                
                // Check for backfiller sources
                if (mapping.type === "BACKFILL_SOURCE") {
                    const wellId = mapping.destination;
                    
                    // Check if this well already exists in rows
                    const existingRow = rows.find(row => row[1] === wellId);
                    
                    if (existingRow) {
                        // Update existing row
                        existingRow[5] = 'Backfiller'; 
                        existingRow[6] = `Liquid: ${mapping.compoundID}`;
                    } else {
                        // Add new row
                        rows.push([
                            currentPlateName,
                            wellId,
                            mapping.compoundID || '',
                            '', // No concentration for backfillers
                            '', // No unit
                            'Backfiller',
                            `Liquid: ${mapping.compoundID}`
                        ]);
                    }
                }
                
                // Check for diluted source wells - this was the missing part
                else if ((mapping.type === "DILUTED_SOURCE" || mapping.isDilutedSource) && 
                        mapping.destinationPlate === currentSourcePlate) {
                    const wellId = mapping.destination;
                    
                    // Check if this well already exists in rows
                    const existingRow = rows.find(row => row[1] === wellId);
                    
                    if (existingRow) {
                        // Update existing row with diluted source info
                        existingRow[2] = mapping.compoundID || '';
                        existingRow[3] = mapping.dilutedConcentration || '';
                        existingRow[4] = mapping.sourceUnit || '';
                        existingRow[5] = 'Diluted Source';
                        existingRow[6] = `Diluted ${mapping.dilutionFactor}x`;
                    } else {
                        // Add new row for diluted source
                        rows.push([
                            currentPlateName,
                            wellId,
                            mapping.compoundID || '',
                            mapping.dilutedConcentration || '',
                            mapping.sourceUnit || '',
                            'Diluted Source',
                            `Diluted ${mapping.dilutionFactor}x`
                        ]);
                    }
                }
                
                // Regular source wells not already in the list
                else if (!mapping.type && !mapping.isDilutedSource) {
                    const sourceWells = parseWellRange(mapping.source);
                    
                    sourceWells.forEach(wellId => {
                        // Check if this well already exists in rows
                        const existingRow = rows.find(row => row[1] === wellId);
                        
                        if (!existingRow) {
                            // Add new row if not already in the list
                            rows.push([
                                currentPlateName,
                                wellId,
                                mapping.compoundID || '',
                                mapping.concentration || mapping.sourceConcentration || '',
                                mapping.concentrationUnit || mapping.sourceUnit || '',
                                'Standard',
                                ''
                            ]);
                        }
                    });
                }
            });
            
            // Convert rows to CSV
            const csvContent = header + rows.map(row => row.join(',')).join('\n');
            
            // Create a safe filename
            const safeFileName = currentPlateName.replace(/[<>:"/\\|?*]/g, '_');
            
            // Export as file
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `source_${safeFileName}_info.csv`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        // Function to export destination plate info
        function exportDestinationPlateInfo() {
            // Get current destination plate
            const currentDestPlate = plates.destination.active;
            const currentPlateName = plates.destination.plates[currentDestPlate] ? 
                plates.destination.plates[currentDestPlate].name : `Plate ${currentDestPlate}`;
            
            // Create header
            const header = 'Plate,Well,Compound ID,Source Plate,Source Well,Transfer Volume (nL),Source Concentration,Source Unit,Destination Concentration,Destination Unit,Type,Notes\n';
            
            // Group mappings by destination well to handle multiple transfers to the same well
            const wellGroups = {};
            
            // Process all mappings for the current destination plate
            mappings.forEach(mapping => {
                if (mapping.destinationPlate !== currentDestPlate) return;
                
                const wellId = mapping.destination;
                if (!wellId) return; // Skip mappings without a destination well
                
                if (!wellGroups[wellId]) {
                    wellGroups[wellId] = [];
                }
                
                wellGroups[wellId].push(mapping);
            });
            
            // Process each well and its mappings
            const rows = [];
            Object.entries(wellGroups).forEach(([wellId, wellMappings]) => {
                // Extract compound mappings and backfill mappings separately
                const compoundMappings = wellMappings.filter(m => !m.type || m.type === "DESTINATION");
                const backfillMappings = wellMappings.filter(m => m.type === "BACKFILL" || m.isBackfill);
                
                // Add compound mappings first
                compoundMappings.forEach(mapping => {
                    // Keep source as curly braces format for consistency
                    const sourceWell = mapping.source || '';
                    
                    // Get source plate name
                    const sourcePlateName = plates.source.plates[mapping.sourcePlate] ? 
                        plates.source.plates[mapping.sourcePlate].name : `Plate ${mapping.sourcePlate}`;
                    
                    rows.push([
                        currentPlateName,
                        wellId,
                        mapping.compoundID || '',
                        sourcePlateName,
                        sourceWell.replace(/[{}]/g, ''),  // Remove curly braces for readability
                        mapping.transferVolume || '',
                        mapping.sourceConcentration || '',
                        mapping.sourceUnit || '',
                        mapping.destinationConcentration || mapping.expectedConcentration || '',
                        mapping.destinationUnit || 'µM',
                        'Compound',
                        mapping.notes || ''
                    ]);
                });
                
                // Then add backfill mappings
                backfillMappings.forEach(mapping => {
                    // Get source plate name
                    const sourcePlateName = plates.source.plates[mapping.sourcePlate] ? 
                        plates.source.plates[mapping.sourcePlate].name : `Plate ${mapping.sourcePlate}`;
                        
                    rows.push([
                        currentPlateName,
                        wellId,
                        `${mapping.compoundID || 'DMSO'} (Backfill)`,
                        sourcePlateName,
                        mapping.source ? mapping.source.replace(/[{}]/g, '') : '',  // Remove curly braces for readability
                        mapping.transferVolume || '',
                        '', // No source concentration for backfill
                        '', // No source unit
                        '', // No destination concentration
                        '', // No destination unit
                        'Backfill',
                        `Backfill liquid: ${mapping.backfillType || mapping.compoundID || 'DMSO'}`
                    ]);
                });
            });
            
            // Convert rows to CSV
            const csvContent = header + rows.map(row => row.join(',')).join('\n');
            
            // Create a safe filename
            const safeFileName = currentPlateName.replace(/[<>:"/\\|?*]/g, '_');
            
            // Export as file
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `destination_${safeFileName}_info.csv`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }
    
        // ----- UI UPDATES -----
        
        // Update map button state
        function updateMapButton() {
            const mapButton = document.getElementById('map-button');
            mapButton.disabled = selectedSourceWells.length === 0 || 
                               selectedDestinationWells.length === 0;
        }
    
        // Update save button state
        function updateSaveButton() {
            const saveButton = document.getElementById('save-button');
            saveButton.disabled = mappings.length === 0;
        }
    
        // Update backfill button state
        function updateApplyBackfillButton() {
            const applyBackfillButton = document.getElementById('apply-backfill');
            const hasSourceWells = selectedSourceWells.length > 0;
            const hasDestWells = selectedDestinationWells.length > 0;
            
            // Need both source and destination wells selected
            applyBackfillButton.disabled = !hasSourceWells || !hasDestWells;
            
            // Update the tooltip based on what's missing
            if (!hasSourceWells && !hasDestWells) {
                applyBackfillButton.title = "Please select source and destination wells for backfill";
            } else if (!hasSourceWells) {
                applyBackfillButton.title = "Please select source wells containing the backfill liquid";
            } else if (!hasDestWells) {
                applyBackfillButton.title = "Please select destination wells to receive the backfill";
            } else {
                applyBackfillButton.title = "Apply backfill to selected wells";
            }
        }
    
        // Initialize rectangular selection
        function initializeRectangleSelection(plateId) {
            const plate = document.getElementById(plateId);
            if (!plate) return;
    
            plate.addEventListener('mousedown', (e) => {
                // Prevent default to avoid text selection
                e.preventDefault();
                
                // Store the current plate ID
                currentPlateId = plateId;
                
                // Initialize drag state
                isDragging = false;
                isMouseDown = true;
                selectionMode = plateId === 'source-plate' ? 'source' : 'destination';
    
                // Get coordinates relative to the plate
                const plateRect = plate.getBoundingClientRect();
                startX = e.clientX - plateRect.left;
                startY = e.clientY - plateRect.top;
    
                // Remove any existing selection box first
                if (selectionBox) {
                    selectionBox.remove();
                    selectionBox = null;
                }
    
                // Create selection box
                selectionBox = document.createElement('div');
                selectionBox.className = 'selection-box';
                plate.appendChild(selectionBox);
                
                // Set initial position
                selectionBox.style.left = `${startX}px`;
                selectionBox.style.top = `${startY}px`;
                selectionBox.style.width = '0px';
                selectionBox.style.height = '0px';
            });
    
            plate.addEventListener('mousemove', (e) => {
                if (!isMouseDown || currentPlateId !== plateId) return;
    
                const plateRect = plate.getBoundingClientRect();
                const currentX = e.clientX - plateRect.left;
                const currentY = e.clientY - plateRect.top;
    
                // Check if movement exceeds drag threshold
                if (Math.abs(currentX - startX) > 5 || Math.abs(currentY - startY) > 5) {
                    isDragging = true;
    
                    // Calculate rectangle dimensions
                    const left = Math.min(currentX, startX);
                    const top = Math.min(currentY, startY);
                    const width = Math.abs(currentX - startX);
                    const height = Math.abs(currentY - startY);
    
                    // Update selection box
                    selectionBox.style.left = `${left}px`;
                    selectionBox.style.top = `${top}px`;
                    selectionBox.style.width = `${width}px`;
                    selectionBox.style.height = `${height}px`;
                    
                    // Get wells within the selection box
                    const wells = plate.querySelectorAll('.well');
                    wells.forEach((well) => {
                        const wellRect = well.getBoundingClientRect();
                        const isInBox = (
                            wellRect.left < plateRect.left + left + width &&
                            wellRect.right > plateRect.left + left &&
                            wellRect.top < plateRect.top + top + height &&
                            wellRect.bottom > plateRect.top + top
                        );
    
                        if (isInBox) {
                            const wellId = well.id.split('_')[1];
                            if (!well.classList.contains('selected')) {
                                toggleWellSelection(well, wellId, plateId);
                            }
                        } else if (isDragging && well.classList.contains('selected')) {
                            const wellId = well.id.split('_')[1];
                            toggleWellSelection(well, wellId, plateId);
                        }
                    });
                }
            });
    
            // Remove selection box on mouseup
            plate.addEventListener('mouseup', () => {
                if (selectionBox) {
                    selectionBox.remove();
                    selectionBox = null;
                }
                isDragging = false;
            });
            
            // Clean up on mouse leave
            plate.addEventListener('mouseleave', () => {
                if (selectionBox) {
                    selectionBox.remove();
                    selectionBox = null;
                }
            });
        }
    
        // Replicate mappings to new plates
        function replicateMappings() {
            const replicationCount = parseInt(document.getElementById('replication-count').value);
            if (replicationCount < 1) {
                alert('Please enter a valid replication count');
                return;
            }
    
            // Get the active destination plate
            const activeDestPlate = plates.destination.active;
            
            // Filter mappings to only include those from the active destination plate
            const currentMappings = mappings.filter(mapping => mapping.destinationPlate === activeDestPlate);
            
            if (currentMappings.length === 0) {
                alert('No mappings found for the active destination plate');
                return;
            }
    
            // Find highest plate number
            const maxDestPlate = Math.max(...Object.keys(plates.destination.plates).map(Number));
    
            // Create new plates and replicate mappings
            for (let i = 1; i <= replicationCount; i++) {
                const newPlateNumber = maxDestPlate + i;
                plates.destination.plates[newPlateNumber] = []; // Add new plate to plates object
    
                // Duplicate mappings for the new plate
                currentMappings.forEach(mapping => {
                    mappings.push({
                        ...mapping,
                        destinationPlate: newPlateNumber
                    });
                });
            }
    
            // Update tabs and initialize click events
            updatePlateTabs('destination');
    
            // Refresh display for the active destination plate
            refreshPlateDisplay('destination');
    
            alert(`Mappings from plate ${activeDestPlate} replicated to ${replicationCount} new plates.`);
        }
    
        // Reset selections and mappings
        function resetSelections() {
            saveStateForUndo('reset', { mappings: [...mappings] });

            if (!confirm('Reset all selections and mappings?')) return;
            
            // Clear selected wells
            selectedSourceWells = [];
            selectedDestinationWells = [];
            
            // Clear all mappings
            mappings = [];
            
            // Clear source well data store
            window.sourceWellDataStore = {};
            
            // Reset form fields
            document.getElementById('source-concentration').value = '';
            document.getElementById('destination-concentration').value = '';
            document.getElementById('final-volume').value = '';
            document.getElementById('transfer-volume').value = '';
            document.getElementById('diluent-volume').textContent = '0.00';
            
            // Reset current compound
            compoundID = null;
            
            // Update displays
            refreshPlateDisplay('source');
            refreshPlateDisplay('destination');
            
            // Update UI
            updateMapButton();
            updateSaveButton();
            updateApplyBackfillButton();
        }
    
        // ----- EVENT LISTENERS -----
        
        // Document-wide event listeners
        document.addEventListener('mouseup', () => {
            isMouseDown = false;
            currentPlateId = null;
            selectionMode = null;
        });
    
        // Compound ID button
        document.getElementById("set-compound-id").addEventListener("click", () => {
            compoundID = document.getElementById("compound-id").value.trim();
    
            if (compoundID) {
                alert(`Compound ID '${compoundID}' has been set.`);
                document.getElementById("map-button").disabled = false;
            } else {
                alert("Please enter a valid Compound ID.");
            }
        });
    
        // Map button
        document.getElementById('map-button').addEventListener('click', createMapping);
        
        // Backfill button
        document.getElementById('apply-backfill').addEventListener('click', applyBackfill);
        
        // Add plate buttons
        document.getElementById('add-source-plate').addEventListener('click', () => addPlate('source'));
        document.getElementById('add-destination-plate').addEventListener('click', () => addPlate('destination'));
        
        // Replicate mappings button
        document.getElementById('replicate-mapping').addEventListener('click', replicateMappings);
        
        // Reset button
        document.getElementById('reset-button').addEventListener('click', resetSelections);
        
        // Save button
        document.getElementById('save-button').addEventListener('click', exportMappings);

        // Undo button
        document.getElementById('undo-button').addEventListener('click', undoLastAction);

        
        // Serial dilution buttons
        document.getElementById('serial-dilution-button').addEventListener('click', () => {
            if (selectedSourceWells.length === 0 || selectedDestinationWells.length === 0) {
                alert('Please select source and destination wells before proceeding with serial dilution');
                return;
            }
    
            // Auto-detect compound ID if not set
            if (!compoundID) {
                // Find compound ID from source wells
                const sourceWellId = selectedSourceWells[0];
                const wellPosition = sourceWellId.split('_')[1];
                const plateNumber = plates.source.active;
                
                // Check well data store
                const wellKey = `${plateNumber}-${wellPosition}`;
                if (window.sourceWellDataStore[wellKey]) {
                    compoundID = window.sourceWellDataStore[wellKey].compoundID;
                    
                    // Also store concentration for later use
                    const concentration = window.sourceWellDataStore[wellKey].concentration;
                    const unit = window.sourceWellDataStore[wellKey].unit;
                    
                    document.getElementById('serial-source-unit').value = unit || 'mM';
                    
                    window.compoundSettings[compoundID] = {
                        ...window.compoundSettings[compoundID],
                        concentration,
                        concentrationUnit: unit
                    };
                }
                
                // If still no compound ID, check mappings
                if (!compoundID) {
                    const mapping = mappings.find(m => {
                        const wells = parseWellRange(m.source);
                        return m.sourcePlate === plateNumber && wells.includes(wellPosition);
                    });
                    
                    if (mapping) {
                        compoundID = mapping.compoundID;
                        
                        // Also store color and concentration
                        window.compoundSettings[compoundID] = {
                            ...window.compoundSettings[compoundID],
                            color: mapping.color,
                            concentration: mapping.concentration,
                            concentrationUnit: mapping.concentrationUnit
                        };
                    }
                }
                
                // If still no compound ID, alert and return
                if (!compoundID) {
                    alert('Please set a Compound ID before proceeding with serial dilution');
                    return;
                }
            }
    
            // Convert selected wells to proper format
            const sourceWellsFormatted = selectedSourceWells.map(wellId => wellId.split('_')[1]);
            const destinationWellsFormatted = selectedDestinationWells.map(wellId => wellId.split('_')[1]);
            
            // Populate the modal inputs
            document.getElementById('serial-source-wells').value = convertWellsToRange(sourceWellsFormatted);
            document.getElementById('serial-destination-wells').value = convertWellsToRange(destinationWellsFormatted);
            
            // Auto-populate source concentration if available from settings
            if (window.compoundSettings[compoundID] && window.compoundSettings[compoundID].concentration) {
                document.getElementById('serial-source-concentration').value = window.compoundSettings[compoundID].concentration;
                
                // Set unit if available
                if (window.compoundSettings[compoundID].concentrationUnit) {
                    document.getElementById('serial-source-unit').value = window.compoundSettings[compoundID].concentrationUnit;
                }
            }
            
            // Prepare and show the modal
            prepareSerialDilutionModal();
        });
        
        document.getElementById('serial-dilution-cancel').addEventListener('click', () => {
            document.getElementById('serial-dilution-modal').style.display = 'none';
        });
        
        document.getElementById('serial-dilution-ok').addEventListener('click', processSerialDilution);
        
        // Split dilution modal buttons
        document.getElementById('split-dilution-cancel').addEventListener('click', () => {
            document.getElementById('dilution-split-modal').style.display = 'none';
        });
        
        // Split-dilution-ok button event handler
        document.getElementById('split-dilution-ok').addEventListener('click', function() {
            console.log("Split dilution OK clicked");
            
            // Get all source well inputs
            const sourceWellInputs = document.querySelectorAll('.new-source-well-input');
            const sourceWells = Array.from(sourceWellInputs).map(input => input.value.trim().toUpperCase());
            
            // Validate that all fields have been filled
            if (sourceWells.some(well => !well)) {
                alert('Please fill in all source well locations');
                return;
            }

            // Get dilution data
            const data = window.dilutionSplitData;
            if (!data || !data.dilutedSources) {
                console.error("Missing dilution data");
                return;
            }

            // Get available wells for validation
            const availableWells = findAvailableSourceWells();
            
            // Validate that wells are actually available or are matching diluted sources with the same compound
            for (let i = 0; i < sourceWells.length; i++) {
                const well = sourceWells[i];
                const dilutedSource = data.dilutedSources[i];
                
                // Check if this well is already a diluted source
                const existingDilutedSource = mappings.find(m => 
                    (m.type === "DILUTED_SOURCE" || m.isDilutedSource) &&
                    m.destinationPlate === plates.source.active &&
                    m.destination === well
                );
                
                // Is well in the available list?
                const isAvailable = availableWells.includes(well);
                
                // Check if both concentration and compound match
                let isMatchingDilutedSource = false;
                
                if (existingDilutedSource) {
                    // Check concentration match (within 1% tolerance)
                    const concentrationMatches = Math.abs(
                        (existingDilutedSource.dilutedConcInMicroMolar - dilutedSource.dilutedConcInMicroMolar) / 
                        dilutedSource.dilutedConcInMicroMolar * 100
                    ) < 1;
                    
                    // Check compound match - compare the original compound IDs
                    const currentCompoundID = compoundID;
                    const existingCompoundID = existingDilutedSource.originalCompoundID || 
                        existingDilutedSource.compoundID.replace(/ \([^)]+\)$/, '');
                    
                    const compoundMatches = (existingCompoundID === currentCompoundID);
                    
                    console.log(`Well ${well} check - Concentration match: ${concentrationMatches}, Compound match: ${compoundMatches}`);
                    console.log(`Comparing compounds: '${existingCompoundID}' vs '${currentCompoundID}'`);
                    
                    // Both must match to reuse the well
                    isMatchingDilutedSource = concentrationMatches && compoundMatches;
                }
                
                // Well is valid if it's either available OR a matching diluted source with same compound
                if (!isAvailable && !isMatchingDilutedSource) {
                    if (existingDilutedSource) {
                        alert(`Well ${well} contains a different compound or concentration than required. Please choose from available wells: ${availableWells.slice(0, 5).join(', ')}${availableWells.length > 5 ? '...' : ''}`);
                    } else {
                        alert(`Well ${well} is not available. Please choose from available wells: ${availableWells.slice(0, 5).join(', ')}${availableWells.length > 5 ? '...' : ''}`);
                    }
                    return;
                }
                
                // If it's a matching diluted source, store it for use in handleSplitDilution
                if (isMatchingDilutedSource) {
                    dilutedSource.existingSource = existingDilutedSource;
                }
            }

            // Process the dilution with the validated source wells
            handleSplitDilution(sourceWells);
        });
        
        // Import/Export buttons
        document.getElementById('import-csv-button').addEventListener('click', () => {
            document.getElementById('csv-file-input').click();
        });
                
        document.getElementById('csv-file-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                readAndProcessCSV(file);
            }
            e.target.value = ''; // Clear the input
        });

        // Export source info button
        document.getElementById('export-source-info').addEventListener('click', exportSourcePlateInfo);

        // Export destination info button
        document.getElementById('export-destination-info').addEventListener('click', exportDestinationPlateInfo);
    
        document.addEventListener('DOMContentLoaded', function() {
            const backfillerInput = document.getElementById('serial-backfiller-wells');
            if (backfillerInput) {
                const newElement = backfillerInput.cloneNode(true);
                backfillerInput.parentNode.replaceChild(newElement, backfillerInput);
            }
            
            document.getElementById('serial-dilution-cancel').addEventListener('click', () => {
                document.getElementById('serial-dilution-modal').style.display = 'none';
                activeSerialInput = null;
            });
            
            document.getElementById('serial-dilution-ok').addEventListener('click', () => {
                activeSerialInput = null;
            });
        });

        
        // Plate type selectors
        document.getElementById('source-plate-type-selector').addEventListener('change', (e) => {
            generatePlate('source-plate', e.target.value);
            refreshPlateDisplay('source');
        });
    
        document.getElementById('destination-plate-type-selector').addEventListener('change', (e) => {
            generatePlate('destination-plate', e.target.value);
            refreshPlateDisplay('destination');
        });
        
        // Concentration and volume calculation listeners
        ['source-concentration', 'destination-concentration', 'final-volume'].forEach(id => {
            document.getElementById(id).addEventListener('input', () => {
                if (document.getElementById('source-concentration').value &&
                    document.getElementById('destination-concentration').value &&
                    document.getElementById('final-volume').value) {
                    calculateTransferVolume();
                }
            });
        });
        
        ['source-concentration-unit', 'destination-concentration-unit'].forEach(id => {
            document.getElementById(id).addEventListener('change', () => {
                if (document.getElementById('source-concentration').value &&
                    document.getElementById('destination-concentration').value &&
                    document.getElementById('final-volume').value) {
                    calculateTransferVolume();
                }
            });
        });
        
        // Transfer volume manual input
        document.getElementById('transfer-volume').addEventListener('input', (e) => {
            const transferVolume = parseFloat(e.target.value);
            if (!isNaN(transferVolume)) {
                const finalVolume = parseFloat(document.getElementById('final-volume').value);
                updateDiluentVolume(transferVolume/1000, finalVolume);
            } else {
                document.getElementById('diluent-volume').textContent = '0.00';
            }
        });
        
        // Add blur event listener to round transfer volume
        document.getElementById('transfer-volume').addEventListener('blur', (e) => {
            const transferVolume = parseFloat(e.target.value);
            if (!isNaN(transferVolume)) {
                const roundedVolume = roundToEchoIncrement(transferVolume);
                e.target.value = roundedVolume.toFixed(2);
                
                const finalVolume = parseFloat(document.getElementById('final-volume').value);
                updateDiluentVolume(roundedVolume/1000, finalVolume);
            }
        });
    
        // ----- INITIALIZATION -----
        
        // Initialize application
        function initializeApp() {
            console.log('Initializing CherryPick App');
            
            // Initialize plates
            generatePlate('source-plate', parseInt(document.getElementById('source-plate-type-selector').value));
            generatePlate('destination-plate', parseInt(document.getElementById('destination-plate-type-selector').value));
            
            // Initialize rectangular selection
            initializeRectangleSelection('source-plate');
            initializeRectangleSelection('destination-plate');
            
            // Initialize plate tabs
            updatePlateTabs('source');
            updatePlateTabs('destination');
            
            // Initialize UI state
            updateMapButton();
            updateSaveButton();
            updateApplyBackfillButton();
            
            // Remove the toggle button for well attributes tables if it exists
            const toggleButton = document.getElementById('toggle-attributes-tables');
            if (toggleButton) {
                toggleButton.remove();
            }
            
            // Create and initialize well attribute tables
            createWellAttributesTables();
            
            // Ensure the tables container is visible
            const tablesContainer = document.querySelector('.attributes-table-container');
            if (tablesContainer) {
                tablesContainer.style.display = 'flex';
            }
        }
    
        // Call initialization function when DOM is loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            initializeApp();
        }
    </script>
</body>

