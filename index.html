<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            background-color: white;
            min-height: 100vh;
            width: 100%;
        }
        
        h2 {
            align-self: flex-start;
            margin-left: 20px;  /* Add some left margin for spacing */
        }

        .container {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: flex-start;
            padding: 10px;
            width: 100%;
            max-width: 100vw;
            box-sizing: border-box;
            gap: 20px;
            overflow-x: auto; /* Allow horizontal scroll if needed */
        }
        .plate-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 10px;
            flex: 1;
            min-width: 0; /* Allow shrinking */
            max-width: 100%; /* Allow growing */
        }
        .plate-container {
            display: grid;
            gap: 1px;
            border: 1px solid #ccc;
            background-color: white;
            padding: 2px;
            width: 45vw;
            height: auto;
            min-height: 300px;
            aspect-ratio: 1.5/1;
            box-sizing: border-box;
            position: relative;  /* Added for tooltips */
        }
        .well {
            background-color: white;
            text-align: center;
            cursor: pointer;
            border: 1px solid #ddd;
            user-select: none;
            border-radius: 20%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0;
            font-weight: 500;
            box-sizing: border-box;
            transition: all 0.2s ease;
        }
        /* Specific well sizes for different plate types */
        .plate-96 .well {
            font-size: clamp(8px, 1.2vw, 14px);
            min-width: calc(45vw / 13);  /* 12 columns + some spacing */
            min-height: calc(45vw / 13 * 0.75);  /* maintain aspect ratio */
        }

        .plate-384 .well {
            font-size: clamp(6px, 0.8vw, 10px);
            min-width: calc(45vw / 25);  /* 24 columns + some spacing */
            min-height: calc(45vw / 25 * 0.75);
        }

        .plate-1536 .well {
            font-size: clamp(4px, 0.6vw, 8px);
            min-width: calc(45vw / 49);  /* 48 columns + some spacing */
            min-height: calc(45vw / 49 * 0.75);
        }
        .selected {
            background-color: blue;
            color: white;
        }
        /* Hover and selection states */
        .well:hover {
            border-color: #007bff;
            box-shadow: 0 0 2px rgba(0, 123, 255, 0.3);
        }

        .well.selected {
            background-color: #007bff;
            color: white;
            border-color: #0056b3;
        }

        .well.mapped,
        .plate-container .well.mapped {
            color: white;
            border-color: rgba(0, 0, 0, 0.2);
            transition: background-color 0.2s ease;
        }
        .mapped {
            color: white;
        }
        .well-tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 1000;
            pointer-events: none;
            white-space: pre-line;
            max-width: 300px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .well-tooltip.visible {
            opacity: 1;
        }

        .well-tooltip::after {
            content: '';
            position: absolute;
            bottom: -4px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 4px;
            border-style: solid;
            border-color: rgba(0, 0, 0, 0.9) transparent transparent transparent;
        }
        
        .button-bar {
            margin: 20px 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: left;
            gap: 10px;
        }
        button {
            padding: 10px 15px;
            margin: 0 5px;
            font-size: 14px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        select {
            padding: 10px;
            font-size: 14px;
            margin-left: 10px;
        }
        .calculation-panel {
            background-color: white;
            padding: 5px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 100vw;
            box-sizing: border-box;
        }
        .input-group {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            gap: 20px;
            margin-bottom: 15px;
            align-items: center;
            min-width: 300px;
        }
        .input-field {
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 300px;
        }
        .input-field input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 150px;
        }
        .input-field label {
            font-size: 14px;
            color: #666;
        }
        .result {
            margin-top: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .compound-id-panel {
            margin: 20px 0;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: nowrap; /* Prevent wrapping */
            justify-content: space-between;
        }

        .compound-id-panel input {
            padding: 5px;
            font-size: 14px;
            width: 200px;
        }

        .compound-id-panel button {
            padding: 5px;
            font-size: 14px;
            cursor: pointer;
        }
        
        .volume-display {
            margin-top: 15px;
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .transfer-volume-box, .diluent-volume-box {
            background-color: #f8f9fa;
            padding: 10px 15px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .transfer-volume-box input {
            margin-top: 5px;
            padding: 5px;
            width: 100px;
            border: 1px solid #ddd;
            border-radius: 4px;
            min-width: 300px;
        }

        .diluent-volume-box span {
            display: block;
            margin-top: 5px;
            font-weight: bold;
            min-width: 100px;
            text-align: center;
        }

        .transfer-volume-box label, .diluent-volume-box label {
            display: block;
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }

        .backfill-section {
            margin-top: 20px;
            padding-top: 15px;
            border-top: none;
        }

        .backfill-section h4 {
            margin-bottom: 15px;
            color: #333;
        }

        .backfill-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }

        .backfill-controls button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .backfill-input-group {
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 300px;
        }

        .backfill-input-group label {
            min-width: 120px;
        }

        .backfill-input-group select {
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .plate-manager {
            width: 100%;
            max-width: 100vw; /* Change from fixed 1500px to 100vw */
            margin: 20px auto;
            padding: 10px;
            box-sizing: border-box;
        }


        .plate-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .plate-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .plate-tabs {
            position: relative; 
            display: flex;
            gap: 5px;
            margin: 10px 0;
            flex-wrap: wrap;
            z-index: 10;
        }

        .plate-tab {
            position: relative; 
            padding: 5px 15px;
            background-color: #e9ecef;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
            z-index: 10;
        }

        .plate-tab.active {
            background-color: #007bff;
            color: white;
            position: relative;
            z-index: 10;
        }

        .plate-tab .remove-plate {
            color: #dc3545;
            font-weight: bold;
            padding: 0 5px;
            cursor: pointer;
        }

        .plate-tab.active .remove-plate {
            color: white;
        }

        .plates-container {
            position: relative;
        }

        .plate-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.1);
            display: none;
            pointer-events: none;
        }

        .replication-controls {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            align-items: center;
        }

        .replication-input {
            width: 60px;
            padding: 5px;
        }
        .selection-box {
            position: absolute;
            background-color: rgba(0, 123, 255, 0.2);
            border: 1px solid #007bff;
            pointer-events: none;
        }
        #serial-dilution-modal {
            display: none;  /* Will be set to block when modal is shown */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #serial-dilution-modal .modal-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.2);
            z-index: 998;
        }

        #serial-dilution-modal .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            width: 600px;
            max-width: 90vw;
            z-index: 999;
        }

        #serial-dilution-modal input[type="text"],
        #serial-dilution-modal input[type="number"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-top: 4px;
        }

        #serial-dilution-modal .input-group {
            margin-bottom: 20px;
        }

        #serial-dilution-modal label {
            display: block;
            margin-bottom: 5px;
            color: #666;
        }

        #serial-dilution-modal .button-bar {
            margin-top: 20px;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        #serial-dilution-modal .button-bar button {
            min-width: 100px;
        }

        /* Style for active selection of backfiller wells */
        .active-selection {
            border: 2px solid #007bff !important;
            box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            width: 100%;
            max-width: 1500px;
            margin: 20px auto;
        }
        .control-layout {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            width: 100%;
            max-width: 100vw;
            margin: 20px auto;
            padding: 0 20px;
            box-sizing: border-box;
        }

        .left-column {
            flex: 0 0 auto; /* Don't grow, don't shrink, size to content */
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .left-column + .calculation-panel {
            flex: 1;
            min-width: 300px; /* Minimum width for usability */
        }

        .left-column .calculation-panel {
            width: auto;
            min-width: 350px; /* Increase from 250px */
        }

        /* Adjust the compound ID input width */
        .compound-id-panel input {
            width: 200px; 
        }

        /* Add media queries for smaller screens */
        @media screen and (max-width: 1200px) {
            .plate-container {
                width: 60vw;
            }
            
            .control-layout {
                grid-template-columns: 1fr 2fr; /* Adjust ratio on smaller screens */
            }
            
            .input-group {
                gap: 10px;
            }
        }

        @media screen and (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .plate-container {
                width: 90vw;
            }
            
            .control-layout {
                grid-template-columns: 1fr; /* Stack on mobile */
            }
            
            .plate-96 .well {
                font-size: clamp(6px, 1vw, 12px);
            }
            
            .plate-384 .well {
                font-size: clamp(4px, 0.8vw, 8px);
            }
            
            .plate-1536 .well {
                font-size: clamp(3px, 0.6vw, 6px);
            }
        }

    </style>
</head>
<body>
    <h2>CherryPick list Maker &#127920&#x1F352&#x1F352&#x1F352</h2>
    <div class="control-layout">
        <!-- Left Column - Three smaller panels -->
        <div class="left-column">
            <!-- Panel 1: Compound ID -->
            <div class="calculation-panel">
                <h3>Compound ID</h3>
                <div class="compound-id-panel">
                    <label for="compound-id">Compound ID</label>
                    <input type="text" id="compound-id" placeholder="Enter Compound ID">
                    <button id="set-compound-id" >Set Compound ID</button>
                </div>
            </div>
            
            <div class="calculation-panel">
                <h3>Serial Dilution</h3>
                <div class="button-bar-serial-dilution">
                </div>
        
            </div>
        
            <div class="calculation-panel">
                <h3>Reset Selections</h3>
                <div class="button-bar">
                    <button id="reset-button">Reset Selections</button>
                </div>
            </div>

            <div class="button-bar">
                <button id="save-button" disabled>Save Mappings </button>
                <select id="format-selector">
                    <option value="json">JSON</option>
                    <option value="csv">CSV</option>
                </select>      
            </div>
        </div>

        <div class="calculation-panel">
            <h3>Manual Mapping</h3>
            <div style="display: flex; gap: 40px;">
                <div style="flex: 1;">
                    <div class="volume-display">
                        <div class="transfer-volume-box" style="width: 100%;">
                            <label for="transfer-volume">Transfer Volume (nL)</label>
                            <input type="number" id="transfer-volume" step="0.01" min="0" style="width: 100%; box-sizing: border-box;">
                        </div>
                    </div>
                    <div class="input-group" style="flex-direction: column; align-items: stretch; gap: 15px;">
                        <div class="input-field" style="width: 100%;">
                            <label for="source-concentration">Source Concentration</label>
                            <div style="display: flex; gap: 5px;">
                                <input type="number" id="source-concentration" step="0.01" min="0" style="flex: 1; width: 100%; box-sizing: border-box;">
                                <select id="source-concentration-unit" style="width: 80px; box-sizing: border-box;">
                                    <option value="mM">mM</option>
                                    <option value="µM">µM</option>
                                </select>
                            </div>
                        </div>
        
                        <div class="input-field" style="width: 100%;">
                            <label for="destination-concentration">Desired Destination Concentration</label>
                            <div style="display: flex; gap: 5px;">
                                <input type="number" id="destination-concentration" step="0.01" min="0" style="flex: 1; width: 100%; box-sizing: border-box;">
                                <select id="destination-concentration-unit" style="width: 80px; box-sizing: border-box;">
                                    <option value="µM">µM</option>
                                    <option value="nM">nM</option>
                                </select>
                            </div>
                        </div>
        
                        <div class="input-field" style="width: 100%;">
                            <label for="final-volume">Final Destination Volume (µL)</label>
                            <input type="number" id="final-volume" step="0.1" min="0" style="width: 100%; box-sizing: border-box;">
                        </div>
        
                        <div class="diluent-volume-box" style="width: 100%;">
                            <label>Diluent Volume (µL)</label>
                            <span id="diluent-volume" style="display: block; width: 100%; padding: 8px 0;">0.00</span>
                        </div>
                    </div>
                    <div class="button-bar">
                        <button id="map-button" disabled>Map Wells</button>
                    </div>
                </div>
        
                <div class="backfill-section" style="flex: 1;">
                    <h4>Backfill</h4>
                    <div class="backfill-controls">
                        <div class="backfill-input-group" style="width: 100%;">
                            <label for="backfill-liquid-selector">Backfilling Liquid:</label>
                            <select id="backfill-liquid-selector" style="width: 100%; box-sizing: border-box;">
                                <option value="DMSO">DMSO</option>
                                <option value="H2O">H2O</option>
                            </select>
                        </div>
                        <p>Use the source plate map to select backfiller wells.</p>
                    </div>
                    <div class="button-bar" style="justify-content: flex-start;">
                        <button id="apply-backfill" disabled>Apply Backfill</button>
                    </div>
                </div>
            </div>
        </div>

    <div class="plate-manager">
        <div class="container">
            <div class="plate-section">
                <h3>Source Plates</h3>
                <div class="plate-controls">
                    <div class="plate-selector">
                        <label>Source Plates:</label>
                        <button id="add-source-plate">Add Source Plate</button>
                        <input type="number" id="source-plate-number" placeholder="Plate #" min="1" value="1">
                    </div>
                </div>
                <div class="plate-tabs" id="source-plate-tabs"></div>
                <select id="source-plate-type-selector">
                    <option value="96">96 Well Plate</option>
                    <option value="384">384 Well Plate</option>
                    <option value="1536">1536 Well Plate</option>
                </select>
                <div class="plates-container">
                    <div class="plate-container" id="source-plate"></div>
                    <div class="plate-overlay" id="source-overlay"></div>
                </div>
            </div>
            
            <div class="plate-section">
                <h3>Destination Plates</h3>
                <div class="plate-controls">
                    <div class="plate-selector">
                        <label>Destination Plates:</label>
                        <button id="add-destination-plate">Add Destination Plate</button>
                        <input type="number" id="destination-plate-number" placeholder="Plate #" min="1" value="1">
                    </div>
                </div>
                <div class="plate-tabs" id="destination-plate-tabs"></div>
                <select id="destination-plate-type-selector">
                    <option value="96">96 Well Plate</option>
                    <option value="384">384 Well Plate</option>
                    <option value="1536">1536 Well Plate</option>
                </select>
                <div class="plates-container">
                    <div class="plate-container" id="destination-plate"></div>
                    <div class="plate-overlay" id="destination-overlay"></div>
                </div>
                <div class="replication-controls">
                    <label>Replicate Mapping:</label>
                    <input type="number" id="replication-count" class="replication-input" min="1" value="1">
                    <button id="replicate-mapping">Replicate to New Plates</button>
                </div>
            </div>
        </div>        
    </div>  
<body>

<script>
    let selectedSourceWells = [];
    let selectedDestinationWells = [];
    let mappings = [];
    let isMouseDown = false;
    let selectionMode = null;
    let currentColorIndex = 0;
    let compoundID = null;
    let backfillingData = [];
    let selectedBackfillerWells = [];
    let isDragging = false;
    let startX = 0;
    let startY = 0;
    let selectionBox = null;
    let currentPlateId = null;
    let plates = {
            source: { active: 1, plates: { 1: [] } },
            destination: { active: 1, plates: { 1: [] } }
        };
        
    const colors = ['#FF5733', '#33FF57', '#3357FF', '#FF33A6', '#FFD433', '#A633FF'];

    function getNextColor() {
        const color = colors[currentColorIndex];
        currentColorIndex = (currentColorIndex + 1) % colors.length;
        return color;
    }
    function convertWellsToRange(wells) {
        if (!wells || wells.length === 0) return "";

        // Sort wells by row (letter) and column (number)
        wells.sort((a, b) => {
            const aRow = a.match(/[A-Z]+/)[0];
            const bRow = b.match(/[A-Z]+/)[0];
            const aCol = parseInt(a.match(/\d+/)[0]);
            const bCol = parseInt(b.match(/\d+/)[0]);
            
            if (aRow === bRow) {
                return aCol - bCol;
            }
            return aRow.localeCompare(bRow);
        });

        const ranges = [];
        let currentRange = {
            row: null,
            start: null,
            end: null
        };

        for (const well of wells) { 
            const row = well.match(/[A-Z]+/)[0];
            const col = parseInt(well.match(/\d+/)[0]);

            if (!currentRange.row) {
                // Start new range
                currentRange = { row, start: col, end: col };
            } else if (row === currentRange.row && col === currentRange.end + 1) {
                // Extend current range
                currentRange.end = col;
            } else {
                // End current range and start new one
                if (currentRange.start === currentRange.end) {
                    ranges.push(`${currentRange.row}${currentRange.start}`);
                } else {
                    ranges.push(`${currentRange.row}${currentRange.start}:${currentRange.row}${currentRange.end}`);
                }
                currentRange = { row, start: col, end: col };
            }
        }

        // Add the last range
        if (currentRange.row) {
            if (currentRange.start === currentRange.end) {
                ranges.push(`${currentRange.row}${currentRange.start}`);
            } else {
                ranges.push(`${currentRange.row}${currentRange.start}:${currentRange.row}${currentRange.end}`);
            }
        }

        return `{${ranges.join(';')}}`;
    }

    function getRowLabel(index) {
                let label = "";
                while (index >= 0) {
                    label = String.fromCharCode(65 + (index % 26)) + label;
                    index = Math.floor(index / 26) - 1;
                }
                return label;
            }

    function generatePlate(plateId, plateType = 96) {
        const plate = document.getElementById(plateId);
        if (!plate) return;
                
        plate.innerHTML = '';
        plate.classList.remove('plate-96', 'plate-384', 'plate-1536');
        plate.classList.add(`plate-${plateType}`);

        let rows, cols;
        switch(plateType) {
            case 384:
                rows = 16;
                cols = 24;
                break;
            case 1536:
                rows = 32;
                cols = 48;
                break;
            default: // 96 well plate
                rows = 8;
                cols = 12;
        }

        plate.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
        plate.style.gridTemplateRows = `repeat(${rows}, 1fr)`;


        // Generate wells
        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                const well = document.createElement('div');
                const wellId = `${getRowLabel(i)}${j + 1}`;
                well.id = `${plateId}_${wellId}`;
                well.className = 'well';
                well.textContent = wellId;
                
                // Add event listeners
                well.addEventListener('mousedown', (e) => {
                    e.preventDefault(); // Prevent text selection
                    isMouseDown = true;
                    selectionMode = plateId === 'source-plate' ? 'source' : 'destination';
                    toggleWellSelection(well, wellId, plateId);
                });

                well.addEventListener('mouseover', () => {
                    if (isMouseDown && selectionMode === (plateId === 'source-plate' ? 'source' : 'destination')) {
                        toggleWellSelection(well, wellId, plateId);
                    }
                });

                plate.appendChild(well);
            }
        }
    }

    function createPlateTab(type, number) {
        const tab = document.createElement('div');
        tab.className = 'plate-tab';
        tab.dataset.plateType = type;
        tab.dataset.number = number;
        
        if (number === plates[type].active) {
            tab.classList.add('active');
        }
        
        tab.innerHTML = `
            Plate ${number}
            <span class="remove-plate" data-number="${number}">&times;</span>
        `;
        
        // Add click handler for the entire tab
        tab.addEventListener('click', (e) => {
            if (!e.target.classList.contains('remove-plate')) {
                switchPlate(type, number);
            }
        });

        // Add click handler for remove button
        const removeBtn = tab.querySelector('.remove-plate');
        removeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            removePlate(type, number);
        });

        return tab;
    }

    function initializeTabs() {
        const tabs = document.querySelectorAll('.plate-tab');
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                // Remove 'active' class from all tabs
                tabs.forEach(t => t.classList.remove('active'));
                // Add 'active' class to clicked tab
                tab.classList.add('active');

                // Get plate number from the tab's data attribute
                const plateType = tab.parentElement.id.includes('source') ? 'source' : 'destination';
                const plateNumber = tab.dataset.number;

                // Update the active plate in the plates object
                plates[plateType].active = parseInt(plateNumber, 10);

                // Refresh the plate display
                refreshPlateDisplay(plateType);
            });
        });
    }

    function switchPlate(type, number) {
        // Update active plate
        plates[type].active = parseInt(number);
        
        // Update tab visual states
        const tabsContainer = document.getElementById(`${type}-plate-tabs`);
        const allTabs = tabsContainer.querySelectorAll('.plate-tab');
        
        allTabs.forEach(tab => {
            if (parseInt(tab.dataset.number) === plates[type].active) {
                tab.classList.add('active');
            } else {
                tab.classList.remove('active');
            }
        });

        // Refresh the plate display
        refreshPlateDisplay(type);
    }

    function removePlate(type, number) {
        const numPlates = Object.keys(plates[type].plates).length;
        if (numPlates <= 1) {
            alert('Cannot remove the last plate');
            return;
        }

        // Remove plate data
        delete plates[type].plates[number];
        
        // If removing active plate, switch to another plate
        if (plates[type].active === parseInt(number)) {
            const remainingPlates = Object.keys(plates[type].plates)
                .map(num => parseInt(num))
                .sort((a, b) => a - b);
            plates[type].active = remainingPlates[0];
        }
        
        // Remove mappings associated with this plate
        mappings = mappings.filter(m => {
            if (type === 'source') {
                return m.sourcePlate !== parseInt(number);
            } else {
                return m.destinationPlate !== parseInt(number);
            }
        });

        // Update UI
        updatePlateTabs(type);
        refreshPlateDisplay(type);
        updateSaveButton();
    }

    function updatePlateTabs(type) {
        const tabsContainer = document.getElementById(`${type}-plate-tabs`);
        tabsContainer.innerHTML = '';

        // Sort plate numbers numerically
        const plateNumbers = Object.keys(plates[type].plates)
            .map(num => parseInt(num))
            .sort((a, b) => a - b);

        // Create and append tabs
        plateNumbers.forEach(number => {
            const tab = createPlateTab(type, number);
            tabsContainer.appendChild(tab);
        });
    }

    // Modify the refresh display function to handle the range format
    function refreshPlateDisplay(type) {
        const plateContainer = document.getElementById(`${type}-plate`);
        // Clear existing selections
        plateContainer.querySelectorAll('.well').forEach(well => {
            well.classList.remove('selected', 'mapped');
            well.style.backgroundColor = '';
        });
        
        // Reapply current plate's mappings
        const currentPlateNumber = plates[type].active;
        mappings.forEach(mapping => {
            if (type === 'destination' && mapping.destinationPlate === currentPlateNumber) {
                const element = document.getElementById(`${type}-plate_${mapping.destination}`);
                if (element) {
                    element.classList.add('mapped');
                    element.style.backgroundColor = mapping.color;
                }
            } else if (type === 'source' && mapping.sourcePlate === currentPlateNumber) {
                // Parse the source wells range and update each well
                const sourceWells = parseWellRange(mapping.source);
                sourceWells.forEach(wellId => {
                    const element = document.getElementById(`${type}-plate_${wellId}`);
                    if (element) {
                        element.classList.add('mapped');
                        element.style.backgroundColor = mapping.color;
                    }
                });
            }
        });
    }
    
    function toggleWellSelection(wellElement, wellId, plateId) {
        const fullWellId = `${plateId}_${wellId}`;
        const isSourcePlate = plateId === 'source-plate';
        const selectedWells = isSourcePlate ? selectedSourceWells : selectedDestinationWells;

        const index = selectedWells.indexOf(fullWellId);
        if (index > -1) {
            selectedWells.splice(index, 1);
            wellElement.classList.remove('selected');
        } else {
            selectedWells.push(fullWellId);
            wellElement.classList.add('selected');
        }

        updateMapButton();
        updateApplyBackfillButton();
    }

    function calculateTransferVolume() {
        const sourceConc = parseFloat(document.getElementById('source-concentration').value);
        const sourceUnit = document.getElementById('source-concentration-unit').value;
        const destConc = parseFloat(document.getElementById('destination-concentration').value);
        const destUnit = document.getElementById('destination-concentration-unit').value;
        const finalVolume = parseFloat(document.getElementById('final-volume').value);
        
        if (sourceConc && destConc && finalVolume) {
            // Convert all concentrations to µM for comparison and calculation
            const sourceConcInMicroMolar = sourceUnit === 'mM' ? sourceConc * 1000 : sourceConc;
            const destConcInMicroMolar = destUnit === 'nM' ? destConc / 1000 : destConc;
            
            if (sourceConcInMicroMolar < destConcInMicroMolar) {
                alert('Error: Source concentration must be higher than destination concentration (after unit conversion)');
                return;
            }
            
            // Calculate transfer volume in microliters first
            const transferVolumeUL = (destConcInMicroMolar * finalVolume) / sourceConcInMicroMolar;
            // Convert to nanoliters (1 µL = 1000 nL)
            const transferVolumeNL = transferVolumeUL * 1000;

            document.getElementById('transfer-volume').value = transferVolumeNL.toFixed(2);
            updateDiluentVolume(transferVolumeUL, finalVolume);
        }
    }

    function updateDiluentVolume(transferVolumeUL, finalVolume) {
        if (!isNaN(transferVolumeUL) && !isNaN(finalVolume)) {
            // Calculate diluent volume in µL
            const diluentVolume = finalVolume - transferVolumeUL;
            document.getElementById('diluent-volume').textContent = diluentVolume.toFixed(2);
        } else {
            document.getElementById('diluent-volume').textContent = '0.00';
        }
    }

    function updateApplyBackfillButton() {
        const applyBackfillButton = document.getElementById('apply-backfill');
        const hasBackfillerWells = selectedSourceWells.length > 0;
        const hasMappings = mappings.length > 0;
        
        applyBackfillButton.disabled = !hasBackfillerWells || !hasMappings;
    }


    // Add event listeners for unit changes
    ['source-concentration-unit', 'destination-concentration-unit'].forEach(id => {
        document.getElementById(id).addEventListener('change', () => {
            if (document.getElementById('source-concentration').value &&
                document.getElementById('destination-concentration').value &&
                document.getElementById('final-volume').value) {
                calculateTransferVolume();
            }
        });
    });


    // Add event listener for manual transfer volume input
    document.getElementById('transfer-volume').addEventListener('input', (e) => {
        const transferVolume = parseFloat(e.target.value);
        const finalVolume = parseFloat(document.getElementById('final-volume').value);
        updateDiluentVolume(transferVolume, finalVolume);
    });

    document.addEventListener('mouseup', () => {
        isMouseDown = false;
        selectionMode = null;
    });


    document.getElementById("set-compound-id").addEventListener("click", () => {
        compoundID = document.getElementById("compound-id").value.trim();
        if (compoundID) {
            alert(`Compound ID '${compoundID}' has been set.`);
            document.getElementById("map-button").disabled = false;
            document.getElementById("compound-id").value = "";
        } else {
            alert("Please enter a valid Compound ID.");
        }
    });


// First, modify the map button event listener
    document.getElementById('map-button').addEventListener('click', () => {
        if (selectedSourceWells.length === 0 || selectedDestinationWells.length === 0) {
            alert('Please select at least one source well and one destination well.');
            return;
        }
        if (!compoundID) {
            alert("Set a Compound ID before mapping wells.");
            return;
        }

        const mappingColor = getNextColor();
        const transferVolume = parseFloat(document.getElementById('transfer-volume').value) || 0;
        const sourcePlate = plates.source.active;
        const destinationPlate = plates.destination.active;

        // Convert source wells to the range format
        const sourceWellsRange = convertWellsToRange(selectedSourceWells.map(wellId => wellId.split('_')[1]));

        // For each destination well, create one mapping with all source wells
        selectedDestinationWells.forEach(destinationWellId => {
            const destinationWell = destinationWellId.split('_')[1];

            // Create a single mapping with the source wells range
            mappings.push({
                sourcePlate,
                destinationPlate,
                source: sourceWellsRange,
                destination: destinationWell,
                transferVolume: transferVolume.toFixed(2),
                compoundID,
                color: mappingColor
            });

            // Update destination well appearance
            const destinationElement = document.getElementById(destinationWellId);
            if (destinationElement) {
                destinationElement.classList.add('mapped');
                destinationElement.style.backgroundColor = mappingColor;
            }
        });

        // Update source wells appearance
        selectedSourceWells.forEach(sourceWellId => {
            const sourceElement = document.getElementById(sourceWellId);
            if (sourceElement) {
                sourceElement.classList.add('mapped');
                sourceElement.style.backgroundColor = mappingColor;
            }
        });

        selectedSourceWells = [];
        selectedDestinationWells = [];
        document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
        updateMapButton();
        updateSaveButton();
        updateApplyBackfillButton();
    });

    document.getElementById("apply-backfill").addEventListener("click", () => {
        // Get backfilling liquid type
        const backfillLiquid = document.getElementById("backfill-liquid-selector").value;
        if (backfillLiquid !== "DMSO" && backfillLiquid !== "H2O") {
            alert("Please select a valid backfilling liquid.");
            return;
        }

        // Ensure backfiller wells are selected
        if (selectedSourceWells.length === 0) {
            alert("Please select at least one backfiller well from the source plate.");
            return;
        }

        const currentSourcePlate = plates.source.active;

        // Convert the selected source wells into the range format
        const backfillerRange = convertWellsToRange(selectedSourceWells.map(wellId => wellId.split('_')[1]));

        // Group mappings by destination plate for volume calculations
        const plateGroups = mappings.reduce((groups, mapping) => {
            const key = mapping.destinationPlate;
            if (!groups[key]) {
                groups[key] = [];
            }
            groups[key].push(mapping);
            return groups;
        }, {});

        // Store new backfill mappings
        const newBackfillMappings = [];

        // Process each destination plate
        Object.entries(plateGroups).forEach(([destPlate, plateMappings]) => {
            // Find the maximum transfer volume for the destination plate
            const maxVolume = Math.max(...plateMappings.map(m => parseFloat(m.transferVolume)));

            // Process each well in this plate
            plateMappings.forEach(mapping => {
                const currentVolume = parseFloat(mapping.transferVolume);
                if (currentVolume < maxVolume) {
                    // Calculate backfill volume needed
                    const backfillVolume = (maxVolume - currentVolume).toFixed(2);

                    // Add backfill mapping
                    newBackfillMappings.push({
                        sourcePlate: currentSourcePlate,
                        source: backfillerRange,
                        destinationPlate: parseInt(destPlate),
                        destination: mapping.destination,
                        transferVolume: backfillVolume,
                        compoundID: backfillLiquid,
                        color: 'rgba(128, 128, 128, 0.3)' // Light gray for backfill
                    });
                }
            });
        });

        // Add all new backfill mappings to the main mappings array
        mappings.push(...newBackfillMappings);

        // Refresh the plate displays
        refreshPlateDisplay('source');
        refreshPlateDisplay('destination');

        // Clear selections
        selectedSourceWells = [];
        selectedDestinationWells = [];
        document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));

        // Update buttons
        updateMapButton();
        updateSaveButton();

        alert(`Backfilling completed. Added ${newBackfillMappings.length} new mappings.`);
    });

    // Add plate buttons event listeners
    document.getElementById('add-source-plate').addEventListener('click', () => {
        const number = parseInt(document.getElementById('source-plate-number').value);
        if (plates.source.plates[number]) {
            alert('Plate number already exists');
            return;
        }
        plates.source.plates[number] = [];
        plates.source.active = number;
        updatePlateTabs('source');
    });

    document.getElementById('add-destination-plate').addEventListener('click', () => {
        const number = parseInt(document.getElementById('destination-plate-number').value);
        if (plates.destination.plates[number]) {
            alert('Plate number already exists');
            return;
        }
        plates.destination.plates[number] = [];
        plates.destination.active = number;
        updatePlateTabs('destination');
    });

    // Replication functionality
    document.getElementById('replicate-mapping').addEventListener('click', () => {
        const replicationCount = parseInt(document.getElementById('replication-count').value);
        if (replicationCount < 1) {
            alert('Please enter a valid replication count');
            return;
        }

        // Get the active destination plate number
        const activeDestPlate = plates.destination.active;
        
        // Filter mappings to only include those from the active destination plate
        const currentMappings = mappings.filter(mapping => mapping.destinationPlate === activeDestPlate);
        
        if (currentMappings.length === 0) {
            alert('No mappings found for the active destination plate');
            return;
        }

        const maxDestPlate = Math.max(...Object.keys(plates.destination.plates).map(Number));

        for (let i = 1; i <= replicationCount; i++) {
            const newPlateNumber = maxDestPlate + i;
            plates.destination.plates[newPlateNumber] = []; // Add new plate to plates object

            // Duplicate mappings for the new plate
            currentMappings.forEach(mapping => {
                mappings.push({
                    ...mapping,
                    destinationPlate: newPlateNumber
                });
            });
        }

        // Update tabs and initialize click events
        updatePlateTabs('destination');

        // Refresh display for the active destination plate
        refreshPlateDisplay('destination');

        alert(`Mappings from plate ${activeDestPlate} replicated to ${replicationCount} new plates.`);
    });


    document.getElementById('reset-button').addEventListener('click', () => {
        selectedSourceWells = [];
        selectedDestinationWells = [];
        mappings = [];
                
        document.querySelectorAll('.selected, .mapped').forEach(el => {
            el.classList.remove('selected');
            el.classList.remove('mapped');
            el.style.backgroundColor='';
        });

        document.getElementById('source-concentration').value = '';
        document.getElementById('destination-concentration').value = '';
        document.getElementById('final-volume').value = '';
        document.getElementById('volume-result').textContent = '';

        updateMapButton();
        updateSaveButton();
        updateApplyBackfillButton();
    });

    // Update the CSV conversion function to handle the source well ranges
    function convertToCSV(mappings) {
        const header = 'Source Plate,Source Well,Destination Plate,Destination Well,Transfer Volume,Compound ID\n';
        // Filter out mappings with transfer volume less than 1nL
        const filteredMappings = mappings.filter(mapping => parseFloat(mapping.transferVolume) >= 1);
        
        // Calculate number of filtered rows and notify user
        const filteredCount = mappings.length - filteredMappings.length;
        if (filteredCount > 0) {
            alert(`${filteredCount} row(s) were filtered out due to transfer volumes less than 1nL`);
        }
        
        const rows = filteredMappings.map(mapping => {
            // Make sure the transfer volume is in nanoliters
            const transferVolumeNL = parseFloat(mapping.transferVolume);
            return `${mapping.sourcePlate},${mapping.source},${mapping.destinationPlate},${mapping.destination},${transferVolumeNL.toFixed(2)},${mapping.compoundID}`;
        }).join('\n');
        return header + rows;
    }

    // Initialize the plate tabs
    updatePlateTabs('source');
    updatePlateTabs('destination');
    
    document.getElementById('save-button').addEventListener('click', () => {
        const format = document.getElementById('format-selector').value;
        let content, filename, type;

        if (format === 'csv') {
            content = convertToCSV(mappings);
            filename = 'mappings.csv';
            type = 'text/csv';
        } else {
            content = JSON.stringify(mappings, null, 2);
            filename = 'mappings.json';
            type = 'application/json';
        }

        const blob = new Blob([content], { type });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    });

    function updateMapButton() {
        const mapButton = document.getElementById('map-button');
        mapButton.disabled = selectedSourceWells.length === 0 || selectedDestinationWells.length === 0;
    }

    function updateSaveButton() {
        const saveButton = document.getElementById('save-button');
        saveButton.disabled = mappings.length === 0;
    }

    document.getElementById('source-plate-type-selector').addEventListener('change', (e) => {
        const sourcePlateType = parseInt(e.target.value);
        generatePlate('source-plate', sourcePlateType);
    });

    document.getElementById('destination-plate-type-selector').addEventListener('change', (e) => {
        const destinationPlateType = parseInt(e.target.value);
        generatePlate('destination-plate', destinationPlateType);
    });

    // Add input event listeners for real-time calculation
    ['source-concentration', 'destination-concentration', 'final-volume'].forEach(id => {
        document.getElementById(id).addEventListener('input', () => {
            if (document.getElementById('source-concentration').value &&
                document.getElementById('destination-concentration').value &&
                document.getElementById('final-volume').value) {
                calculateTransferVolume();
            }
        });
    });

    function initializeRectangleSelection(plateId) {
        const plate = document.getElementById(plateId);
        if (!plate) return;

        plate.addEventListener('mousedown', (e) => {
            // Prevent default to avoid text selection
            e.preventDefault();
            
            // Store the current plate ID
            currentPlateId = plateId;
            
            // Initialize drag state
            isDragging = false;
            isMouseDown = true;
            selectionMode = plateId === 'source-plate' ? 'source' : 'destination';

            // Get coordinates relative to the plate
            const plateRect = plate.getBoundingClientRect();
            startX = e.clientX - plateRect.left;
            startY = e.clientY - plateRect.top;

            // Remove any existing selection box first
            removeSelectionBox();

            // Create selection box
            selectionBox = document.createElement('div');
            selectionBox.className = 'selection-box';
            plate.appendChild(selectionBox);
            
            // Set initial position
            selectionBox.style.left = `${startX}px`;
            selectionBox.style.top = `${startY}px`;
            selectionBox.style.width = '0px';
            selectionBox.style.height = '0px';
        });

        plate.addEventListener('mousemove', (e) => {
            if (!isMouseDown || currentPlateId !== plateId) return;

            const plateRect = plate.getBoundingClientRect();
            const currentX = e.clientX - plateRect.left;
            const currentY = e.clientY - plateRect.top;

            // Check if movement exceeds drag threshold
            if (Math.abs(currentX - startX) > 5 || Math.abs(currentY - startY) > 5) {
                isDragging = true;

                // Calculate rectangle dimensions
                const left = Math.min(currentX, startX);
                const top = Math.min(currentY, startY);
                const width = Math.abs(currentX - startX);
                const height = Math.abs(currentY - startY);

                // Update selection box
                selectionBox.style.left = `${left}px`;
                selectionBox.style.top = `${top}px`;
                selectionBox.style.width = `${width}px`;
                selectionBox.style.height = `${height}px`;
                
                // Get wells within the selection box
                const wells = plate.querySelectorAll('.well');
                wells.forEach((well) => {
                    const wellRect = well.getBoundingClientRect();
                    const isInBox = (
                        wellRect.left < plateRect.left + left + width &&
                        wellRect.right > plateRect.left + left &&
                        wellRect.top < plateRect.top + top + height &&
                        wellRect.bottom > plateRect.top + top
                    );

                    if (isInBox) {
                        const wellId = well.id.split('_')[1];
                        if (!well.classList.contains('selected')) {
                            toggleWellSelection(well, wellId, plateId);
                        }
                    } else if (isDragging && well.classList.contains('selected')) {
                        const wellId = well.id.split('_')[1];
                        toggleWellSelection(well, wellId, plateId);
                    }
                });
            }
        });

        // Helper function to remove selection box
        function removeSelectionBox() {
            if (selectionBox) {
                selectionBox.remove();
                selectionBox = null;
            }
        }

        // Add mouseup handler to document instead of plate
        document.addEventListener('mouseup', (e) => {
            if (!isMouseDown) return;
            
            // Handle single well selection on mouseup if we haven't dragged
            if (!isDragging) {
                const clickedElement = document.elementFromPoint(e.clientX, e.clientY);
                if (clickedElement && clickedElement.classList.contains('well') && 
                    clickedElement.id.startsWith(currentPlateId)) {
                    const wellId = clickedElement.id.split('_')[1];
                    toggleWellSelection(clickedElement, wellId, currentPlateId);
                }
            }

            // Always remove the selection box on mouseup
            removeSelectionBox();
            
            isDragging = false;
            isMouseDown = false;
            currentPlateId = null;
            selectionMode = null;
        });
        
        // Add cleanup on mouse leave
        plate.addEventListener('mouseleave', () => {
            if (selectionBox) {
                removeSelectionBox();
            }
        });
    }


    // Modify the toggleWellSelection function to handle backfiller input
    function toggleWellSelection(wellElement, wellId, plateId) {
        const fullWellId = `${plateId}_${wellId}`;
        const isSourcePlate = plateId === 'source-plate';
        let selectedWells = isSourcePlate ? selectedSourceWells : selectedDestinationWells;

        // If we're in serial dilution modal and selecting backfiller wells
        if (activeSerialInput === 'serial-backfiller-wells' && isSourcePlate) {
            const backfillerInput = document.getElementById('serial-backfiller-wells');
            const index = selectedSourceWells.indexOf(fullWellId);
            
            if (index > -1) {
                selectedSourceWells.splice(index, 1);
                wellElement.classList.remove('selected');
            } else {
                selectedSourceWells.push(fullWellId);
                wellElement.classList.add('selected');
            }

            // Convert selected wells to range format and update input
            const wellsRange = convertWellsToRange(selectedSourceWells.map(wellId => wellId.split('_')[1]));
            backfillerInput.value = wellsRange;
            
            return; // Exit early as we don't need to update the map button
        }

        // Regular well selection logic
        const index = selectedWells.indexOf(fullWellId);
        if (index > -1) {
            selectedWells.splice(index, 1);
            wellElement.classList.remove('selected');
        } else {
            selectedWells.push(fullWellId);
            wellElement.classList.add('selected');
        }

        updateMapButton();
        updateApplyBackfillButton();
    }

    // First, add the HTML for the modal to the body of the document
    const serialDilutionModal = document.createElement('div');
    serialDilutionModal.id = 'serial-dilution-modal';
    serialDilutionModal.style.display = 'none';
    serialDilutionModal.innerHTML = `
        <div class="modal-backdrop"></div>
        <div class="modal-content">
            <h3>Serial Dilution Setup</h3>
            <div class="input-group">
                <div class="input-field">
                    <label>Source Well(s):</label>
                    <input type="text" id="serial-source-wells" readonly>
                </div>
                <div class="input-field">
                    <label>Source Concentration:</label>
                    <input type="number" id="serial-source-concentration" min="0" step="0.01">
                </div>
                <select id="serial-source-unit" style="height: 40px;">
                    <option value="mM">mM</option>
                    <option value="µM">µM</option>
                    <option value="nM">nM</option>
                </select>
            </div>
            
            <div class="input-group">
                <div class="input-field">
                    <label>Destination Wells:</label>
                    <input type="text" id="serial-destination-wells" readonly>
                </div>
                <div class="input-field">
                    <label>Top Dilution Concentration:</label>
                    <input type="number" id="serial-top-concentration" min="0" step="0.01">
                </div>
                <select id="serial-top-unit" style="height: 40px;">
                    <option value="µM">µM</option>
                    <option value="nM">nM</option>
                </select>
            </div>
            
            <div class="input-group">
                <div class="input-field">
                    <label>Final Volume (µL):</label>
                    <input type="number" id="serial-final-volume" min="0" step="0.01" value="100">
                </div>
                <div class="input-field">
                    <label>Dilution Factor:</label>
                    <input type="number" id="serial-dilution-fold" min="2" step="1" value="2">
                </div>
            </div>

            <div class="input-group">
                <div class="input-field">
                    <label>Backfiller Wells:</label>
                    <input type="text" id="serial-backfiller-wells" placeholder="Enter backfiller wells (e.g. {A1:A12})" style="width: 100%">
                </div>
                <div class="input-field">
                    <label>Backfill Fluid:</label>
                    <select id="serial-backfill-fluid" style="width: 100%">
                        <option value="DMSO">DMSO</option>
                        <option value="H2O">H2O</option>
                        <option value="Buffer">Buffer</option>
                    </select>
                </div>
            </div>

            <div class="input-group">
                <div>
                    <label>Dilution Direction:</label>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                        <label><input type="radio" name="direction" value="top-bottom" checked> Top → Bottom</label>
                        <label><input type="radio" name="direction" value="bottom-top"> Bottom → Top</label>
                        <label><input type="radio" name="direction" value="left-right"> Left → Right</label>
                        <label><input type="radio" name="direction" value="right-left"> Right → Left</label>
                    </div>
                </div>
            </div>

            <div class="input-group">
                <div class="input-field">
                    <label>Number of Replicates:</label>
                    <input type="number" id="serial-replicates" min="1" value="1" step="1">
                </div>
            </div>

            <div class="button-bar">
                <button id="serial-dilution-cancel">Cancel</button>
                <button id="serial-dilution-ok">Apply Serial Dilution</button>
            </div>
        </div>`;

    document.body.appendChild(serialDilutionModal);

    // Remove any existing code that tries to add replicates input separately
    // since it's now part of the modal HTML structure

    // Add button to the main button bar
    const serialDilutionButton = document.createElement('button');
    serialDilutionButton.id = 'serial-dilution-button';
    serialDilutionButton.textContent = 'Serial Dilution';
    document.querySelector('.button-bar-serial-dilution').appendChild(serialDilutionButton);

    // Track which input field is currently active for well selection
    let activeSerialInput = null;

    // First, modify the event listener for the serial dilution button
    document.getElementById('serial-dilution-button').addEventListener('click', () => {
        if (selectedSourceWells.length === 0 || selectedDestinationWells.length === 0) {
            alert('Please select source and destination wells before proceeding with serial dilution');
            return;
        }

        if (!compoundID) {
            alert('Please set a Compound ID before proceeding with serial dilution');
            return;
        }

        // Convert selected wells to the proper format
        const sourceWells = convertWellsToRange(selectedSourceWells.map(wellId => wellId.split('_')[1]));
        const destinationWells = convertWellsToRange(selectedDestinationWells.map(wellId => wellId.split('_')[1]));

        // Populate the modal inputs
        document.getElementById('serial-source-wells').value = sourceWells;
        document.getElementById('serial-destination-wells').value = destinationWells;
        
        // Show the modal
        serialDilutionModal.style.display = 'block';
    });

    document.getElementById('serial-dilution-modal').addEventListener('click', (e) => {
        if (e.target.classList.contains('modal-backdrop')) {
            document.getElementById('serial-dilution-modal').style.display = 'none';
        }
    });

    // Remove the click listeners from the input fields since they'll be auto-populated
    ['serial-source-wells', 'serial-destination-wells'].forEach(id => {
        const input = document.getElementById(id);
        input.removeEventListener('click', null);
        input.readOnly = true;
    });

    document.getElementById('serial-dilution-cancel').addEventListener('click', () => {
        serialDilutionModal.style.display = 'none';
    });

    // Only handle source and destination wells
    ['serial-source-wells', 'serial-destination-wells'].forEach(id => {
        const input = document.getElementById(id);
        input.addEventListener('click', () => {
            // Remove active-selection class from all inputs
            document.querySelectorAll('.active-selection').forEach(el => el.classList.remove('active-selection'));
            
            // Clear previous selections and selected wells styling
            selectedSourceWells = [];
            selectedDestinationWells = [];
            document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
            
            // Set the active input
            activeSerialInput = id;
            input.classList.add('active-selection');
        });
    });

    // Add event listener to clear activeSerialInput when clicking outside the modal
    document.addEventListener('click', (e) => {
        const modal = document.querySelector('#serial-dilution-modal .modal-content');
        const plates = document.querySelectorAll('.plate-container');
        
        // If clicking outside modal and plates, clear active input
        if (!modal?.contains(e.target) && ![...plates].some(plate => plate.contains(e.target))) {
            activeSerialInput = null;
            document.querySelectorAll('.active-selection').forEach(el => el.classList.remove('active-selection'));
        }
    });

    // Function to convert well array to formatted string
    function formatWellsForDisplay(wells) {
        return wells.map(well => well.split('_')[1]).join(', ');
    }

    function processSerialDilution() {
        // Parse inputs with strict number validation
        const sourceConc = Number(document.getElementById('serial-source-concentration').value);
        const sourceUnit = document.getElementById('serial-source-unit').value;
        const topConc = Number(document.getElementById('serial-top-concentration').value);
        const topUnit = document.getElementById('serial-top-unit').value;
        const dilutionFold = Number(document.getElementById('serial-dilution-fold').value);
        const replicates = Number(document.getElementById('serial-replicates').value);
        const finalVolume = Number(document.getElementById('serial-final-volume').value);

        // Convert all concentrations to µM for calculations
        let sourceConcInMicroMolar;
        switch(sourceUnit) {
            case 'mM':
                sourceConcInMicroMolar = sourceConc * 1000;
                break;
            case 'nM':
                sourceConcInMicroMolar = sourceConc / 1000;
                break;
            default: // µM
                sourceConcInMicroMolar = sourceConc;
        }
        
        const topConcInMicroMolar = topUnit === 'nM' ? topConc / 1000 : topConc;

        // Debug log input values
        console.log('Input values:', {
            sourceConc,
            topConc,
            dilutionFold,
            replicates,
            finalVolume
        });

        // Validate all numeric inputs
        if (isNaN(sourceConc) || isNaN(topConc) || isNaN(dilutionFold) || 
            isNaN(replicates) || isNaN(finalVolume)) {
            console.error('Invalid numeric input detected');
            alert('Please ensure all numeric fields have valid values');
            return;
        }

        if (sourceConc <= 0 || topConc <= 0 || dilutionFold <= 0 || 
            replicates <= 0 || finalVolume <= 0) {
            console.error('All numeric values must be greater than 0');
            alert('All numeric values must be greater than 0');
            return;
        }

        if (sourceConcInMicroMolar < topConcInMicroMolar) {
            alert('Source concentration must be higher than the top dilution concentration (after unit conversion)');
            return;
        }

        // Parse well inputs
        const sourceWells = parseWellRange(document.getElementById('serial-source-wells').value);
        const destinationWells = parseWellRange(document.getElementById('serial-destination-wells').value);
        const backfillerWells = parseWellRange(document.getElementById('serial-backfiller-wells').value);
        const direction = document.querySelector('input[name="direction"]:checked').value;

        // Debug log well counts
        console.log('Well counts:', {
            sourceWells: sourceWells.length,
            destinationWells: destinationWells.length,
            backfillerWells: backfillerWells.length
        });

        // Validate number of wells matches replicates
        if (destinationWells.length % replicates !== 0) {
            alert(`Number of destination wells (${destinationWells.length}) must be divisible by number of replicates (${replicates})`);
            return;
        }

        // Calculate number of unique concentration points
        const numConcentrations = destinationWells.length / replicates;

        // Calculate dilution series
        const dilutionSeries = [];
        let currentConc = topConcInMicroMolar;  // Note we're using the microMolar version
        
         // Calculate the reference transfer volume in nanoliters
        const maxTransferVolumeUL = (topConcInMicroMolar * finalVolume) / sourceConcInMicroMolar;
        const initialTransferVolumeNL = maxTransferVolumeUL * 1000;

        // Find the maximum transfer volume for this compound ID across all existing mappings
        const existingMaxTransferVolume = mappings
            .filter(mapping => mapping.compoundID === compoundID)
            .reduce((max, mapping) => {
                const volume = parseFloat(mapping.transferVolume);
                return volume > max ? volume : max;
            }, 0);

        // Use the larger of the two volumes for backfilling
        const maxTransferVolumeNL = Math.max(initialTransferVolumeNL, existingMaxTransferVolume);

        for (let i = 0; i < numConcentrations; i++) {
            const transferVolumeUL = (currentConc * finalVolume) / sourceConcInMicroMolar;
            const transferVolumeNL = transferVolumeUL * 1000;
            const backfillVolumeNL = maxTransferVolumeNL - transferVolumeNL;

            dilutionSeries.push({
                concentration: currentConc,
                transferVolume: transferVolumeNL,
                backfillVolume: backfillVolumeNL
            });

            currentConc /= dilutionFold;
        }

        // Sort wells based on direction
        const sortedWells = sortWellsByDirection(destinationWells, direction);
        
        // Group wells into concentration points with replicates
        const replicateGroups = [];
        for (let i = 0; i < numConcentrations; i++) {
            const startIdx = i * replicates;
            replicateGroups.push(sortedWells.slice(startIdx, startIdx + replicates));
        }

        // Clear existing mappings for these wells
        mappings = mappings.filter(mapping => 
            !destinationWells.includes(mapping.destination));

        // Get new color for visualization
        const baseColor = getNextColor();
        const [r, g, b] = baseColor.startsWith('#') 
            ? [parseInt(baseColor.slice(1, 3), 16), parseInt(baseColor.slice(3, 5), 16), parseInt(baseColor.slice(5, 7), 16)]
            : baseColor.match(/\d+/g).map(Number);

        // Create mappings for each concentration and its replicates
        replicateGroups.forEach((replicateGroup, groupIndex) => {
            const dilutionStep = dilutionSeries[groupIndex];
            const alpha = 1 - (groupIndex / (numConcentrations - 1)) * 0.8;
            const wellColor = `rgba(${r}, ${g}, ${b}, ${alpha})`;

            // Process each replicate for this concentration
            replicateGroup.forEach(well => {
                // Add source to destination mapping
                mappings.push({
                    sourcePlate: plates.source.active,
                    destinationPlate: plates.destination.active,
                    source: document.getElementById('serial-source-wells').value,
                    destination: well,
                    transferVolume: dilutionStep.transferVolume.toFixed(2),
                    compoundID: compoundID,
                    color: wellColor,
                    concentration: dilutionStep.concentration.toFixed(2)
                });

                // Add backfill mapping if needed
                if (dilutionStep.backfillVolume > 0) {
                    mappings.push({
                        sourcePlate: plates.source.active,
                        destinationPlate: plates.destination.active,
                        source: document.getElementById('serial-backfiller-wells').value,
                        destination: well,
                        transferVolume: dilutionStep.backfillVolume.toFixed(2),
                        compoundID: document.getElementById('serial-backfill-fluid').value,
                        color: 'rgba(128, 128, 128, 0.2)',
                        referenceCompoundID: compoundID  // Add this to track which compound this backfill is for
                    });
                }
            });
        });

        // Log final mappings for debugging
        console.log('Final mappings:', mappings);

        // Update visuals
        refreshPlateDisplay('source');
        refreshPlateDisplay('destination');
        updateMapButton();
        updateSaveButton();

        // Clear selections
        selectedSourceWells = [];
        selectedDestinationWells = [];
        document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
    }

    // Updated well sorting function to handle replicate grouping
    function sortWellsByDirection(wells, direction) {
        const wellPositions = wells.map(well => {
            const [row, col] = parseWellPosition(well);
            return { well, row, col };
        });

        switch (direction) {
            case 'top-bottom':
                // Sort by column first, then row
                return wellPositions
                    .sort((a, b) => a.col - b.col || a.row - b.row)
                    .map(pos => pos.well);
            case 'bottom-top':
                // Sort by column first, then reverse row
                return wellPositions
                    .sort((a, b) => a.col - b.col || b.row - a.row)
                    .map(pos => pos.well);
            case 'left-right':
                // Sort by row first, then column
                return wellPositions
                    .sort((a, b) => a.row - b.row || a.col - b.col)
                    .map(pos => pos.well);
            case 'right-left':
                // Sort by row first, then reverse column
                return wellPositions
                    .sort((a, b) => a.row - b.row || b.col - a.col)
                    .map(pos => pos.well);
        }
    }

    // Helper function to parse well position (A1 -> [0,0], B2 -> [1,1], etc.)
    function parseWellPosition(well) {
        const match = well.match(/([A-Z]+)(\d+)/);
        if (!match) return [0, 0];
        
        const row = match[1].split('').reduce((acc, char) => acc * 26 + char.charCodeAt(0) - 64, 0) - 1;
        const col = parseInt(match[2]) - 1;
        return [row, col];
    }

    // Rename the helper function for serial dilution
    function calculateSerialTransferVolume(destConc, sourceConc) {
        return (destConc / sourceConc) * 100; // Assuming 100µL total volume
    }


    // Helper function to adjust color alpha
    function adjustColorAlpha(color, alpha) {
        const rgb = color.match(/\d+/g);
        return `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${alpha})`;
    }

    // Function to parse well range format like "{A1 ; A2 ; A3}" into array
    function parseWellRange(range) {
        if (!range) return [];
        
        // Handle ranges with colons (e.g., "A1:A12")
        const expandRange = (rangeStr) => {
            if (!rangeStr.includes(':')) return [rangeStr];
            
            const [start, end] = rangeStr.split(':');
            const startRow = start.match(/[A-Z]+/)[0];
            const endRow = end.match(/[A-Z]+/)[0];
            const startCol = parseInt(start.match(/\d+/)[0]);
            const endCol = parseInt(end.match(/\d+/)[0]);
            
            if (startRow !== endRow) return [rangeStr]; // Don't expand if rows are different
            
            const wells = [];
            for (let i = startCol; i <= endCol; i++) {
                wells.push(`${startRow}${i}`);
            }
            return wells;
        };

        // Remove curly braces, split by semicolon, and expand any ranges
        return range.replace(/[{}]/g, '')
            .split(';')
            .map(part => part.trim())
            .filter(part => part)
            .flatMap(part => expandRange(part));
    }

    document.getElementById('serial-dilution-ok').addEventListener('click', () => {
        const backfillerInput = document.getElementById('serial-backfiller-wells').value;
        const sourceConc = document.getElementById('serial-source-concentration').value;
        const topConc = document.getElementById('serial-top-concentration').value;
        const dilutionFold = document.getElementById('serial-dilution-fold').value;
        const replicates = document.getElementById('serial-replicates').value;

        if (!backfillerInput || !sourceConc || !topConc || !dilutionFold || !replicates) {
            alert('Please fill in all required fields');
            return;
        }

        processSerialDilution();
        serialDilutionModal.style.display = 'none';
    });

    // Update validation to include final volume check
    function validateSerialDilutionInputs() {
        const requiredFields = [
            { id: 'serial-source-wells', name: 'Source Wells' },
            { id: 'serial-destination-wells', name: 'Destination Wells' },
            { id: 'serial-backfiller-wells', name: 'Backfiller Wells' },
            { id: 'serial-source-concentration', name: 'Source Concentration' },
            { id: 'serial-top-concentration', name: 'Top Concentration' },
            { id: 'serial-dilution-fold', name: 'Dilution Factor' },
            { id: 'serial-replicates', name: 'Replicates' },
            { id: 'final-volume', name: 'Final Volume' }
        ];
        
        for (const field of requiredFields) {
            const element = document.getElementById(field.id);
            if (!element) {
                alert(`Missing field: ${field.name}`);
                return false;
            }
            const value = element.value.trim();
            if (!value) {
                alert(`Please fill in the ${field.name} field`);
                element.focus();
                return false;
            }
        }
        
        const sourceConc = parseFloat(document.getElementById('serial-source-concentration').value);
        const topConc = parseFloat(document.getElementById('serial-top-concentration').value);
        
        if (sourceConc < topConc) {
            alert('Source concentration must be higher than the top dilution concentration');
            return false;
        }
        
        return true;
    }
    // Add styles
    const style = document.createElement('style');
    style.textContent = `
        .active-selection {
            border: 2px solid #007bff !important;
            box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
        }
    `;
    document.head.appendChild(style);

    // Add missing replicates input to the modal HTML
    const serialModal = document.querySelector('#serial-dilution-modal .modal-content');
    if (!serialModal.querySelector('#serial-replicates')) {
        const replicatesGroup = document.createElement('div');
        replicatesGroup.className = 'input-group';
        replicatesGroup.innerHTML = `
            <div class="input-field">
                <label>Number of Replicates:</label>
                <input type="number" id="serial-replicates" min="1" value="1" step="1">
            </div>
        `;
        serialModal.querySelector('.button-bar').insertAdjacentElement('beforebegin', replicatesGroup);
    }

    // First, let's remove any existing event listeners
    document.getElementById('serial-dilution-ok')?.removeEventListener('click', processSerialDilution);
    document.getElementById('serial-dilution-ok')?.removeEventListener('click', () => {});

    // Reattach the event listener
    document.getElementById('serial-dilution-ok').addEventListener('click', () => {
        processSerialDilution();
        document.getElementById('serial-dilution-modal').style.display = 'none';
    });

    // Update validation function
    function validateSerialDilutionInputs() {
        const requiredFields = [
            { id: 'serial-source-wells', name: 'Source Wells' },
            { id: 'serial-destination-wells', name: 'Destination Wells' },
            { id: 'serial-backfiller-wells', name: 'Backfiller Wells' },
            { id: 'serial-source-concentration', name: 'Source Concentration' },
            { id: 'serial-top-concentration', name: 'Top Concentration' },
            { id: 'serial-dilution-fold', name: 'Dilution Factor' },
            { id: 'serial-replicates', name: 'Replicates' }
        ];
        
        for (const field of requiredFields) {
            const element = document.getElementById(field.id);
            const value = element.value.trim();
            if (!value) {
                alert(`Please fill in the ${field.name} field`);
                element.focus();
                return false;
            }
        }
        
        // Additional validation
        const sourceConc = parseFloat(document.getElementById('serial-source-concentration').value);
        const topConc = parseFloat(document.getElementById('serial-top-concentration').value);
        
        if (sourceConc < topConc) {
            alert('Source concentration must be higher than the top dilution concentration');
            return false;
        }
        
        return true;
    }

    // Re-attach the event listener for the OK button
    document.getElementById('serial-dilution-ok').addEventListener('click', () => {
        processSerialDilution();
        document.getElementById('serial-dilution-modal').style.display = 'none';
    });


    // Add event listeners for unit changes
    ['serial-source-unit', 'serial-top-unit'].forEach(id => {
        document.getElementById(id).addEventListener('change', () => {
            if (document.getElementById('serial-source-concentration').value && 
                document.getElementById('serial-top-concentration').value) {
                // Revalidate concentrations when units change
                const sourceConc = Number(document.getElementById('serial-source-concentration').value);
                const sourceUnit = document.getElementById('serial-source-unit').value;
                const topConc = Number(document.getElementById('serial-top-concentration').value);
                const topUnit = document.getElementById('serial-top-unit').value;
                
                let sourceConcInMicroMolar;
                switch(sourceUnit) {
                    case 'mM':
                        sourceConcInMicroMolar = sourceConc * 1000;
                        break;
                    case 'nM':
                        sourceConcInMicroMolar = sourceConc / 1000;
                        break;
                    default: // µM
                        sourceConcInMicroMolar = sourceConc;
                }

                const topConcInMicroMolar = topUnit === 'nM' ? topConc / 1000 : topConc;
                
                if (sourceConcInMicroMolar < topConcInMicroMolar) {
                    alert('Source concentration must be higher than the top dilution concentration (after unit conversion)');
                }
            }
        });
    });

    // Add tooltip container
    let tooltip = document.createElement('div');
    tooltip.className = 'well-tooltip';
    document.body.appendChild(tooltip);

    function getWellInfo(wellElement, plateId) {
        const wellId = wellElement.id.split('_')[1];
        const isSource = plateId === 'source-plate';
        const plateNumber = plates[isSource ? 'source' : 'destination'].active;
        
        // Find all mappings related to this well
        let wellMappings = mappings.filter(mapping => {
            if (isSource) {
                return mapping.sourcePlate === plateNumber && 
                    parseWellRange(mapping.source).includes(wellId);
            } else {
                return mapping.destinationPlate === plateNumber && 
                    mapping.destination === wellId;
            }
        });

        if (wellMappings.length === 0) return null;

        if (isSource) {
            // Source well info
            const uniqueCompounds = [...new Set(wellMappings.map(m => m.compoundID))];
            return uniqueCompounds.map(compound => {
                const mappingsForCompound = wellMappings.filter(m => m.compoundID === compound);
                const sourceConc = document.getElementById('source-concentration').value;
                const sourceUnit = document.getElementById('source-concentration-unit').value;
                return `Compound: ${compound}\nConcentration: ${sourceConc} ${sourceUnit}`;
            }).join('\n\n');
        } else {
            // Destination well info
            return wellMappings.map(mapping => {
                // Find backfill mapping if it exists
                const backfillMapping = mappings.find(m => 
                    m.destinationPlate === mapping.destinationPlate && 
                    m.destination === mapping.destination && 
                    m.compoundID.includes('DMSO') || m.compoundID.includes('H2O')
                );

                let info = [
                    `Compound: ${mapping.compoundID}`,
                    `Source Wells: ${mapping.source}`,
                    `Source Plate: ${mapping.sourcePlate}`,
                    `Transfer Volume: ${mapping.transferVolume} nL`
                ];

                // Add concentration info if available
                if (mapping.concentration) {
                    info.push(`Concentration: ${mapping.concentration} µM`);
                }

                // Add backfill info if exists
                if (backfillMapping) {
                    info.push(`Backfill: ${backfillMapping.transferVolume} nL ${backfillMapping.compoundID}`);
                }

                return info.join('\n');
            }).join('\n\n');
        }
    }

    function updateTooltipPosition(e, tooltip) {
        const padding = 10;
        const tooltipRect = tooltip.getBoundingClientRect();
        
        let x = e.pageX;
        let y = e.pageY - tooltipRect.height - padding;

        // Adjust if tooltip would go off screen
        if (x + tooltipRect.width > window.innerWidth) {
            x = window.innerWidth - tooltipRect.width - padding;
        }
        if (y < 0) {
            y = e.pageY + padding;
        }

        tooltip.style.left = `${x}px`;
        tooltip.style.top = `${y}px`;
    }

    function initializeWellTooltips() {
        document.querySelectorAll('.well').forEach(well => {
            well.addEventListener('mouseenter', (e) => {
                const plateId = well.id.split('_')[0];
                const info = getWellInfo(well, plateId);
                
                if (info) {
                    tooltip.textContent = info;
                    tooltip.classList.add('visible');
                    updateTooltipPosition(e, tooltip);
                }
            });

            well.addEventListener('mousemove', (e) => {
                if (tooltip.classList.contains('visible')) {
                    updateTooltipPosition(e, tooltip);
                }
            });

            well.addEventListener('mouseleave', () => {
                tooltip.classList.remove('visible');
            });
        });
    }

    // Update generatePlate function to initialize tooltips after creating wells
    const originalGeneratePlate = generatePlate;
    generatePlate = function(plateId, plateType = 96) {
        originalGeneratePlate(plateId, plateType);
        initializeWellTooltips();
    };



    // Function to initialize everything
    function initializeApplication() {
        // Initialize plates
        generatePlate('source-plate', 96);
        generatePlate('destination-plate', 96);

        // Initialize rectangle selection
        ['source-plate', 'destination-plate'].forEach((id) => {
            initializeRectangleSelection(id);
        });

        // Initialize plate tabs
        ['source', 'destination'].forEach(type => {
            updatePlateTabs(type);
        });
        updateApplyBackfillButton();
    }

    // Main initialization - will handle both DOMContentLoaded and already loaded cases
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeApplication);
    } else {
        initializeApplication();
    }

</script>

</script>